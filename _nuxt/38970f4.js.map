{"version":3,"sources":["webpack:///./node_modules/libphonenumber-js/es6/AsYouTypeState.js","webpack:///./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.util.js","webpack:///./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.complete.js","webpack:///./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternParser.js","webpack:///./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternMatcher.js","webpack:///./node_modules/libphonenumber-js/es6/AsYouTypeFormatter.js","webpack:///./node_modules/libphonenumber-js/es6/AsYouTypeParser.js","webpack:///./node_modules/libphonenumber-js/es6/AsYouType.js","webpack:///./node_modules/libphonenumber-js/min/exports/AsYouType.js"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","AsYouTypeState","_ref","onCountryChange","onCallingCodeChange","instance","Constructor","TypeError","_classCallCheck","this","protoProps","staticProps","value","defaultCountry","defaultCallingCode","international","IDDPrefix","undefined","missingPlus","callingCode","digits","resetNationalSignificantNumber","initCountryAndCallingCode","nationalSignificantNumber","getNationalDigits","nationalSignificantNumberMatchesInput","nationalPrefix","carrierCode","complexPrefixBeforeNationalSignificantNumber","properties","_i","_Object$keys","keys","country","setCountry","setCallingCode","nextDigits","slice","prototype","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","call","next","bind","Array","isArray","minLen","_arrayLikeToArray","n","toString","constructor","name","from","test","_unsupportedIterableToArray","done","arr","len","arr2","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","RegExp","repeat","string","times","result","cutAndStripNonPairedParens","cutBeforeIndex","dangling_braces","push","pop","start","cleared_string","_dangling_braces","index","stripNonPairedParens","formatCompleteNumber","state","format","metadata","shouldTryNationalPrefixFormattingRule","getSeparatorAfterNationalPrefix","concat","pattern","_ref2","formattedNumber","formatNationalNumber","useNationalPrefixFormattingRule","formatNationalNumberWithAndWithoutNationalPrefixFormattingRule","_ref3","formattedNationalNumber","formatNationalNumberUsingFormat","useInternationalFormat","withNationalPrefix","parseDigits","isValidFormattedNationalNumber","PatternParser","context","or","instructions","parsePattern","Error","_this$context$","branches","op","args","expandSingleElementArray","match","OPERATOR","operator","before","rightPart","startContext","getContext","endContext","oneOfSet","parseOneOfSet","ILLEGAL_CHARACTER_REGEXP","split","values","prevValue","charCodeAt","nextValue","String","fromCharCode","array","PatternMatcher","matchTree","parse","arguments","allowOverflow","_match","matchedChars","overflow","characters","tree","last","characterString","join","indexOf","partialMatch","restCharacters","JSON","stringify","_step","_iterator","_result","_step2","_iterator2","_char","LONGEST_DUMMY_PHONE_NUMBER","NATIONAL_PREFIX_SEPARATORS_PATTERN","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","NON_ALTERING_FORMAT_REG_EXP","AsYouTypeFormatter","resetFormat","chosenFormat","template","nationalNumberTemplate","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","numberingPlan","isNANP","matchingFormats","formats","narrowDownMatchingFormats","_this","checkNumberLength","formattedCompleteNumber","setNationalNumberTemplate","replace","lastIndexOf","formatNationalNumberWithNextDigits","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","_this2","leadingDigits","leadingDigitsPatternIndex","filter","formatSuits","formatMatches","usesNationalPrefix","nationalPrefixIsOptionalWhenFormattingInNationalFormat","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","error","console","internationalFormat","_this3","_loop","getFormatFormat","createTemplateForFormat","_","_ret","getTemplateForFormat","nationalPrefixFormattingRule","options","spacing","internationalPrefix","getInternationalPrefixBeforeCountryCallingCode","getDigitsWithoutInternationalPrefix","_ref4","strictPattern","nationalNumberDummyDigits","nationalPrefixIncludedInTemplate","numberFormat","numberFormatWithNationalPrefix","applyInternationalSeparatorStyle","position","digit","search","populateTemplateWithDigits","_ref5","_slicedToArray","_arrayWithHoles","_s","_e","_arr","_n","_d","err","_iterableToArrayLimit","_nonIterableRest","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN","VALID_FORMATTED_PHONE_NUMBER_PART","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","COMPLEX_NATIONAL_PREFIX","AsYouTypeParser","onNationalSignificantNumberChange","text","justLeadingPlus","_extractFormattedDigi","_extractFormattedDigi4","extractedNumber","hasPlus","startsAt","extractFormattedPhoneNumber","_extractFormattedDigitsAndPlus","formattedDigits","extractFormattedDigitsAndPlus","_extractFormattedDigi2","startInternationalNumber","inputDigits","hasReceivedThreeLeadingDigits","appendDigits","extractIddPrefix","isWaitingForCountryCallingCode","extractCountryCallingCode","appendNationalSignificantNumberDigits","hasExtractedNationalSignificantNumber","extractNationalSignificantNumber","stateUpdate","update","_extractCountryCallin","countryCallingCode","number","hasSelectedNumberingPlan","nationalPrefixForParsing","_nationalPrefixForParsing","couldPossiblyExtractAnotherNationalSignificantNumber","nationalDigits","setState","_extractNationalNumbe","extractNationalNumberFromPossiblyIncompleteNumber","nationalNumber","onExtractedNationalNumber","prevNationalSignificantNumber","_extractNationalNumbe2","nationalSignificantNumberIndex","prefixBeforeNationalNumber","extractAnotherNationalSignificantNumber","fixMissingPlus","extractCallingCodeAndNationalSignificantNumber","numberWithoutIDD","stripIddPrefix","_extractCountryCallin2","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","newCallingCode","_typeof","obj","AsYouType","optionsOrDefaultCountry","_this$getCountryAndCa2","getCountryAndCallingCode","reset","hasCountry","_this$parser$input","parser","input","formattedOutput","determineTheCountryIfNeeded","formatter","reExtractNationalSignificantNumber","getFullNumber","getNonFormattedNumber","selectNumberingPlan","isInternational","getCallingCode","_getCountry","isCountryCallingCodeAmbiguous","determineTheCountry","prefix","_this$state","getNonFormattedNationalNumberWithPrefix","countryCodes","getCountryCodesForCallingCode","getCountryByCallingCode","_this$state2","_this$state3","phoneNumber","PhoneNumber","getNumber","isPossible","isValid","getTemplate","getNonFormattedTemplate","create"],"mappings":"2JAEA,SAASA,EAAkBC,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAAa,CAAE,CAI5T,IAAIO,EAA8B,WAChC,SAASA,EAAeC,GACtB,IAAIC,EAAkBD,EAAKC,gBACvBC,EAAsBF,EAAKE,qBATnC,SAAyBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,oCAAwC,CAWpJC,CAAgBC,KAAMR,GAEtBQ,KAAKN,gBAAkBA,EACvBM,KAAKL,oBAAsBA,CAC7B,CAXF,IAAsBE,EAAaI,EAAYC,EA6G7C,OA7GoBL,EAaPL,GAboBS,EAaJ,CAAC,CAC5BV,IAAK,QACLY,MAAO,SAAeC,EAAgBC,GACpCL,KAAKM,eAAgB,EACrBN,KAAKO,eAAYC,EACjBR,KAAKS,iBAAcD,EACnBR,KAAKU,iBAAcF,EACnBR,KAAKW,OAAS,GACdX,KAAKY,iCACLZ,KAAKa,0BAA0BT,EAAgBC,EACjD,GACC,CACDd,IAAK,iCACLY,MAAO,WACLH,KAAKc,0BAA4Bd,KAAKe,oBACtCf,KAAKgB,uCAAwC,EAC7ChB,KAAKiB,oBAAiBT,EACtBR,KAAKkB,iBAAcV,EACnBR,KAAKmB,kDAA+CX,CACtD,GACC,CACDjB,IAAK,SACLY,MAAO,SAAgBiB,GACrB,IAAK,IAAIC,EAAK,EAAGC,EAAejC,OAAOkC,KAAKH,GAAaC,EAAKC,EAAatC,OAAQqC,IAAM,CACvF,IAAI9B,EAAM+B,EAAaD,GACvBrB,KAAKT,GAAO6B,EAAW7B,EACzB,CACF,GACC,CACDA,IAAK,4BACLY,MAAO,SAAmCqB,EAASd,GACjDV,KAAKyB,WAAWD,GAChBxB,KAAK0B,eAAehB,EACtB,GACC,CACDnB,IAAK,aACLY,MAAO,SAAoBqB,GACzBxB,KAAKwB,QAAUA,EACfxB,KAAKN,gBAAgB8B,EACvB,GACC,CACDjC,IAAK,iBACLY,MAAO,SAAwBO,GAC7BV,KAAKU,YAAcA,EACnBV,KAAKL,oBAAoBe,EAAaV,KAAKwB,QAC7C,GACC,CACDjC,IAAK,2BACLY,MAAO,SAAkCqB,EAASd,GAEhDV,KAAKM,eAAgB,EAIrBN,KAAKa,0BAA0BW,EAASd,EAC1C,GACC,CACDnB,IAAK,eACLY,MAAO,SAAsBwB,GAC3B3B,KAAKW,QAAUgB,CACjB,GACC,CACDpC,IAAK,wCACLY,MAAO,SAA+CwB,GACpD3B,KAAKc,2BAA6Ba,CACpC,GASC,CACDpC,IAAK,oBACLY,MAAO,WACL,OAAIH,KAAKM,cACAN,KAAKW,OAAOiB,OAAO5B,KAAKO,UAAYP,KAAKO,UAAUvB,OAAS,IAAMgB,KAAKU,YAAcV,KAAKU,YAAY1B,OAAS,IAGjHgB,KAAKW,MACd,GACC,CACDpB,IAAK,sCACLY,MAAO,WACL,OAAIH,KAAKM,eACHN,KAAKO,UACAP,KAAKW,OAAOiB,MAAM5B,KAAKO,UAAUvB,QAIrCgB,KAAKW,MACd,MA1G0E/B,EAAkBiB,EAAYgC,UAAW5B,GAAiBC,GAAatB,EAAkBiB,EAAaK,GAAcb,OAAOC,eAAeO,EAAa,YAAa,CAAET,UAAU,IA6GrPI,CACT,CA5GkC,GCNlC,SAASsC,EAAgCC,EAAGC,GAAkB,IAAIC,EAAuB,oBAAXC,QAA0BH,EAAEG,OAAOC,WAAaJ,EAAE,cAAe,GAAIE,EAAI,OAAQA,EAAKA,EAAGG,KAAKL,IAAIM,KAAKC,KAAKL,GAAK,GAAIM,MAAMC,QAAQT,KAAOE,EAExN,SAAqCF,EAAGU,GAAU,IAAKV,EAAG,OAAQ,GAAiB,iBAANA,EAAgB,OAAOW,EAAkBX,EAAGU,GAAS,IAAIE,EAAItD,OAAOwC,UAAUe,SAASR,KAAKL,GAAGH,MAAM,GAAI,GAAc,WAANe,GAAkBZ,EAAEc,cAAaF,EAAIZ,EAAEc,YAAYC,MAAM,GAAU,QAANH,GAAqB,QAANA,EAAa,OAAOJ,MAAMQ,KAAKhB,GAAI,GAAU,cAANY,GAAqB,2CAA2CK,KAAKL,GAAI,OAAOD,EAAkBX,EAAGU,EAAS,CAFlMQ,CAA4BlB,KAAOC,GAAkBD,GAAyB,iBAAbA,EAAE/C,OAAqB,CAAMiD,IAAIF,EAAIE,GAAI,IAAIlD,EAAI,EAAG,OAAO,WAAc,OAAIA,GAAKgD,EAAE/C,OAAe,CAAEkE,MAAM,GAAe,CAAEA,MAAM,EAAO/C,MAAO4B,EAAEhD,KAAQ,CAAG,CAAE,MAAM,IAAIe,UAAU,wIAA0I,CAI3lB,SAAS4C,EAAkBS,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAInE,UAAQoE,EAAMD,EAAInE,QAAQ,IAAK,IAAID,EAAI,EAAGsE,EAAO,IAAId,MAAMa,GAAMrE,EAAIqE,EAAKrE,IAAOsE,EAAKtE,GAAKoE,EAAIpE,GAAM,OAAOsE,CAAM,CAG/K,IAAIC,EAAoB,IAE3BC,EAA4B,IAAIC,OAAOF,GAsBpC,SAASG,EAAOC,EAAQC,GAC7B,GAAIA,EAAQ,EACV,MAAO,GAKT,IAFA,IAAIC,EAAS,GAEND,EAAQ,GACD,EAARA,IACFC,GAAUF,GAGZC,IAAU,EACVD,GAAUA,EAGZ,OAAOE,EAASF,CAClB,CACO,SAASG,EAA2BH,EAAQI,GAKjD,MAJ+B,MAA3BJ,EAAOI,IACTA,IAqBG,SAA8BJ,GACnC,IAAIK,EAAkB,GAClBhF,EAAI,EAER,KAAOA,EAAI2E,EAAO1E,QACE,MAAd0E,EAAO3E,GACTgF,EAAgBC,KAAKjF,GACE,MAAd2E,EAAO3E,IAChBgF,EAAgBE,MAGlBlF,IAGF,IAAImF,EAAQ,EACRC,EAAiB,GACrBJ,EAAgBC,KAAKN,EAAO1E,QAE5B,IAAK,IAAIqC,EAAK,EAAG+C,EAAmBL,EAAiB1C,EAAK+C,EAAiBpF,OAAQqC,IAAM,CACvF,IAAIgD,EAAQD,EAAiB/C,GAC7B8C,GAAkBT,EAAO9B,MAAMsC,EAAOG,GACtCH,EAAQG,EAAQ,CAClB,CAEA,OAAOF,CACT,CA3CSG,CAAqBZ,EAAO9B,MAAM,EAAGkC,GAC9C,C,+BCpDe,SAASS,EAAqBC,EAAOC,EAAQhF,GAC1D,IAAIiF,EAAWjF,EAAKiF,SAChBC,EAAwClF,EAAKkF,sCAC7CC,EAAkCnF,EAAKmF,gCAG3C,GAFc,IAAIpB,OAAO,OAAOqB,OAAOJ,EAAOK,UAAW,OAE7C9B,KAAKwB,EAAM1D,2BACrB,OAWJ,SAAwE0D,EAAOC,EAAQM,GACrF,IAAIL,EAAWK,EAAML,SACjBC,EAAwCI,EAAMJ,sCAC9CC,EAAkCG,EAAMH,gCAEZJ,EAAM1D,0BAClB0D,EAAMlE,cACLkE,EAAMvD,eACTuD,EAAMtD,YAWxB,GAAIyD,EAAsCF,GAAS,CACjD,IAAIO,EAAkBC,EAAqBT,EAAOC,EAAQ,CACxDS,iCAAiC,EACjCN,gCAAiCA,EACjCF,SAAUA,IAGZ,GAAIM,EACF,OAAOA,CAEX,CAGA,OAAOC,EAAqBT,EAAOC,EAAQ,CACzCS,iCAAiC,EACjCN,gCAAiCA,EACjCF,SAAUA,GAEd,CAhDWS,CAA+DX,EAAOC,EAAQ,CACnFC,SAAUA,EACVC,sCAAuCA,EACvCC,gCAAiCA,GAGvC,CA4CA,SAASK,EAAqBT,EAAOC,EAAQW,GAC3C,IAAIV,EAAWU,EAAMV,SACjBQ,EAAkCE,EAAMF,gCACxCN,EAAkCQ,EAAMR,gCACxCS,EAA0B,OAAAC,EAAA,GAAgCd,EAAM1D,0BAA2B2D,EAAQ,CACrGvD,YAAasD,EAAMtD,YACnBqE,uBAAwBf,EAAMlE,cAC9BkF,mBAAoBN,EACpBR,SAAUA,IAaZ,GAVKQ,IACCV,EAAMvD,eAGRoE,EAA0Bb,EAAMvD,eAAiB2D,EAAgCH,GAAUY,EAClFb,EAAMrD,+CACfkE,EAA0Bb,EAAMrD,6CAA+C,IAAMkE,IAsC3F,SAAwCA,EAAyBb,GAC/D,OAAO,OAAAiB,EAAA,GAAYJ,KAA6Bb,EAAMzD,mBACxD,CApCM2E,CAA+BL,EAAyBb,GAC1D,OAAOa,CAEX,CClFA,SAAS,EAAkBxG,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAAa,CAAE,CAI5T,IAAI0G,EAA6B,WAC/B,SAASA,KAPX,SAAyB/F,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,oCAAwC,CAQpJ,CAAgBE,KAAM2F,EACxB,CALF,IAAsB9F,EAAaI,EAAYC,EAgL7C,OAhLoBL,EAOP8F,GAPoB1F,EAOL,CAAC,CAC3BV,IAAK,QACLY,MAAO,SAAe2E,SAOpB,GANA9E,KAAK4F,QAAU,CAAC,CACdC,IAAI,EACJC,aAAc,KAEhB9F,KAAK+F,aAAajB,SAEU,IAAxB9E,KAAK4F,QAAQ5G,OACf,MAAM,IAAIgH,MAAM,wDAGlB,IAAIC,EAAiBjG,KAAK4F,QAAQ,GAC9BM,EAAWD,EAAeC,SAC1BJ,EAAeG,EAAeH,aAElC,GAAII,EACF,MAAO,CACLC,GAAI,IACJC,KAAMF,EAASrB,OAAO,CAACwB,EAAyBP,MAMpD,GAA4B,IAAxBA,EAAa9G,OACf,MAAM,IAAIgH,MAAM,uBAGlB,OAA4B,IAAxBF,EAAa9G,OACR8G,EAAa,GAGfA,CACT,GACC,CACDvG,IAAK,eACLY,MAAO,SAAsByF,GAC3B5F,KAAK4F,QAAQ5B,KAAK4B,EACpB,GACC,CACDrG,IAAK,aACLY,MAAO,WACLH,KAAK4F,QAAQ3B,KACf,GACC,CACD1E,IAAK,aACLY,MAAO,WACL,OAAOH,KAAK4F,QAAQ5F,KAAK4F,QAAQ5G,OAAS,EAC5C,GACC,CACDO,IAAK,eACLY,MAAO,SAAsB2E,SAC3B,IAAKA,QACH,MAAM,IAAIkB,MAAM,uBAGlB,IAAIM,EAAQxB,QAAQwB,MAAMC,GAE1B,GAAKD,EAAL,CASA,IAAIE,EAAWF,EAAM,GACjBG,EAAS3B,QAAQlD,MAAM,EAAG0E,EAAMjC,OAChCqC,EAAY5B,QAAQlD,MAAM0E,EAAMjC,MAAQmC,EAASxH,QAErD,OAAQwH,GACN,IAAK,MACCC,GACFzG,KAAK+F,aAAaU,GAGpBzG,KAAK2G,aAAa,CAChBd,IAAI,EACJC,aAAc,GACdI,SAAU,KAEZ,MAEF,IAAK,IACH,IAAKlG,KAAK4G,aAAaf,GACrB,MAAM,IAAIG,MAAM,mDAOlB,GAJIS,GACFzG,KAAK+F,aAAaU,GAG0B,IAA1CzG,KAAK4G,aAAad,aAAa9G,OACjC,MAAM,IAAIgH,MAAM,6DAGlB,IACIE,EADmBlG,KAAK4G,aACIV,SAEhCA,EAASlC,KAAKqC,EAAyBrG,KAAK4G,aAAad,eACzD9F,KAAK6G,aACL7G,KAAK4G,aAAad,aAAa9B,KAAK,CAClCmC,GAAI,IACJC,KAAMF,IAER,MAEF,IAAK,IACH,IAAKlG,KAAK4G,aAAaf,GACrB,MAAM,IAAIG,MAAM,oDAQlB,GALIS,GACFzG,KAAK+F,aAAaU,IAIfzG,KAAK4G,aAAaV,SAAU,CAI/B,GAA4B,IAAxBlG,KAAK4F,QAAQ5G,OAGf,MAAM,IAAIgH,MAAM,iDAFhBhG,KAAK4G,aAAaV,SAAW,EAIjC,CAEAlG,KAAK4G,aAAaV,SAASlC,KAAKqC,EAAyBrG,KAAK4G,aAAad,eAC3E9F,KAAK4G,aAAad,aAAe,GACjC,MAEF,IAAK,IACCW,GACFzG,KAAK+F,aAAaU,GAGpBzG,KAAK2G,aAAa,CAChBG,UAAU,IAEZ,MAEF,IAAK,IACH,IAAK9G,KAAK4G,aAAaE,SACrB,MAAM,IAAId,MAAM,iDAGlBhG,KAAK6G,aACL7G,KAAK4G,aAAad,aAAa9B,KAAK,CAClCmC,GAAI,KACJC,KAAMW,EAAcN,KAEtB,MAIF,QACE,MAAM,IAAIT,MAAM,qBAAqBnB,OAAO2B,IAG5CE,GACF1G,KAAK+F,aAAaW,EAjGpB,KAPA,CACE,GAAIM,EAAyBhE,KAAK8B,SAChC,MAAM,IAAIkB,MAAM,0CAA0CnB,OAAOC,UAGnE9E,KAAK4G,aAAad,aAAe9F,KAAK4G,aAAad,aAAajB,OAAOC,QAAQmC,MAAM,IAEvF,CAmGF,MA7K0E,EAAkBpH,EAAYgC,UAAW5B,GAAiBC,GAAa,EAAkBL,EAAaK,GAAcb,OAAOC,eAAeO,EAAa,YAAa,CAAET,UAAU,IAgLrPuG,CACT,CA/KiC,GAmLjC,SAASoB,EAAcjC,SAIrB,IAHA,IAAIoC,EAAS,GACTnI,EAAI,EAEDA,EAAI+F,QAAQ9F,QAAQ,CACzB,GAAmB,MAAf8F,QAAQ/F,GAAY,CACtB,GAAU,IAANA,GAAWA,IAAM+F,QAAQ9F,OAAS,EACpC,MAAM,IAAIgH,MAAM,wCAAwCnB,OAAOC,UAOjE,IAJA,IAAIqC,EAAYrC,QAAQ/F,EAAI,GAAGqI,WAAW,GAAK,EAC3CC,EAAYvC,QAAQ/F,EAAI,GAAGqI,WAAW,GAAK,EAC3CjH,EAAQgH,EAELhH,GAASkH,GACdH,EAAOlD,KAAKsD,OAAOC,aAAapH,IAChCA,GAEJ,MACE+G,EAAOlD,KAAKc,QAAQ/F,IAGtBA,GACF,CAEA,OAAOmI,CACT,CAEA,IAAIF,EAA2B,mBAC3BT,EAAW,IAAI/C,OACnB,+BAWA,SAAS6C,EAAyBmB,GAChC,OAAqB,IAAjBA,EAAMxI,OACDwI,EAAM,GAGRA,CACT,CCxOA,SAAS,EAAgCzF,EAAGC,GAAkB,IAAIC,EAAuB,oBAAXC,QAA0BH,EAAEG,OAAOC,WAAaJ,EAAE,cAAe,GAAIE,EAAI,OAAQA,EAAKA,EAAGG,KAAKL,IAAIM,KAAKC,KAAKL,GAAK,GAAIM,MAAMC,QAAQT,KAAOE,EAExN,SAAqCF,EAAGU,GAAU,IAAKV,EAAG,OAAQ,GAAiB,iBAANA,EAAgB,OAAO,EAAkBA,EAAGU,GAAS,IAAIE,EAAItD,OAAOwC,UAAUe,SAASR,KAAKL,GAAGH,MAAM,GAAI,GAAc,WAANe,GAAkBZ,EAAEc,cAAaF,EAAIZ,EAAEc,YAAYC,MAAM,GAAU,QAANH,GAAqB,QAANA,EAAa,OAAOJ,MAAMQ,KAAKhB,GAAI,GAAU,cAANY,GAAqB,2CAA2CK,KAAKL,GAAI,OAAO,EAAkBZ,EAAGU,EAAS,CAFlM,CAA4BV,KAAOC,GAAkBD,GAAyB,iBAAbA,EAAE/C,OAAqB,CAAMiD,IAAIF,EAAIE,GAAI,IAAIlD,EAAI,EAAG,OAAO,WAAc,OAAIA,GAAKgD,EAAE/C,OAAe,CAAEkE,MAAM,GAAe,CAAEA,MAAM,EAAO/C,MAAO4B,EAAEhD,KAAQ,CAAG,CAAE,MAAM,IAAIe,UAAU,wIAA0I,CAI3lB,SAAS,EAAkBqD,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAInE,UAAQoE,EAAMD,EAAInE,QAAQ,IAAK,IAAID,EAAI,EAAGsE,EAAO,IAAId,MAAMa,GAAMrE,EAAIqE,EAAKrE,IAAOsE,EAAKtE,GAAKoE,EAAIpE,GAAM,OAAOsE,CAAM,CAItL,SAAS,EAAkBxE,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAAa,CAAE,CAM5T,IAAI,EAA8B,WAChC,SAASwI,EAAe3C,UAT1B,SAAyBlF,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,oCAAwC,CAUpJ,CAAgBE,KAAMyH,GAEtBzH,KAAK0H,WAAY,IAAI/B,GAAgBgC,MAAM7C,QAC7C,CATF,IAAsBjF,EAAaI,EAAYC,EAqC7C,OArCoBL,EAWP4H,EAXoBxH,EAWJ,CAAC,CAC5BV,IAAK,QACLY,MAAO,SAAeuD,GACpB,IAAIjE,EAAOmI,UAAU5I,OAAS,QAAsBwB,IAAjBoH,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC5EC,EAAgBpI,EAAKoI,cAEzB,IAAKnE,EACH,MAAM,IAAIsC,MAAM,sBAGlB,IAAIpC,EAASkE,EAAOpE,EAAOuD,MAAM,IAAKjH,KAAK0H,WAAW,GAMtD,GAJI9D,GAAUA,EAAO0C,cACZ1C,EAAOmE,cAGZnE,IAAUA,EAAOoE,UACdH,EAKP,OAAOjE,CACT,IAlC8D3D,GAAY,EAAkBJ,EAAYgC,UAAW5B,GAAiBC,GAAa,EAAkBL,EAAaK,GAAcb,OAAOC,eAAeO,EAAa,YAAa,CAAET,UAAU,IAqCrPqI,CACT,CAlCkC,GA8ClC,SAASK,EAAOG,EAAYC,EAAMC,GAOhC,GAAoB,iBAATD,EAAmB,CAC5B,IAAIE,EAAkBH,EAAWI,KAAK,IAEtC,OAAsC,IAAlCH,EAAKI,QAAQF,GAMXH,EAAWjJ,SAAWkJ,EAAKlJ,OACtB,CACLsH,OAAO,EACPyB,aAAcE,GASX,CACLM,cAAc,GAKoB,IAAlCH,EAAgBE,QAAQJ,GACtBC,GAUEF,EAAWjJ,OAASkJ,EAAKlJ,OACpB,CACLgJ,UAAU,GAKT,CACL1B,OAAO,EACPyB,aAAcE,EAAWrG,MAAM,EAAGsG,EAAKlJ,cAI3C,CACF,CAEA,GAAIuD,MAAMC,QAAQ0F,GAAO,CAIvB,IAHA,IAAIM,EAAiBP,EAAWrG,QAC5B7C,EAAI,EAEDA,EAAImJ,EAAKlJ,QAAQ,CACtB,IAEI4E,EAASkE,EAAOU,EAFNN,EAAKnJ,GAE0BoJ,GAAQpJ,IAAMmJ,EAAKlJ,OAAS,GAEzE,IAAK4E,EACH,OACK,GAAIA,EAAOoE,SAChB,OAAOpE,EACF,IAAIA,EAAO0C,MAiBX,CAEL,GAAI1C,EAAO2E,aACT,MAAO,CACLA,cAAc,GAIhB,MAAM,IAAIvC,MAAM,8BAA8BnB,OAAO4D,KAAKC,UAAU9E,EAAQ,KAAM,IAEtF,CAvBE,GAA8B,KAF9B4E,EAAiBA,EAAe5G,MAAMgC,EAAOmE,aAAa/I,SAEvCA,OACjB,OAAID,IAAMmJ,EAAKlJ,OAAS,EACf,CACLsH,OAAO,EACPyB,aAAcE,GAGT,CACLM,cAAc,GAiBtBxJ,GACF,CAMA,OAAIoJ,EACK,CACLH,UAAU,GAIP,CACL1B,OAAO,EACPyB,aAAcE,EAAWrG,MAAM,EAAGqG,EAAWjJ,OAASwJ,EAAexJ,QAEzE,CAEA,OAAQkJ,EAAK/B,IACX,IAAK,IAGH,IAFA,IAAIoC,EAE6DI,EAAxDC,EAAY,EAAgCV,EAAK9B,QAAgBuC,EAAQC,KAAa1F,MAAO,CACpG,IAEI2F,EAAUf,EAAOG,EAFRU,EAAMxI,MAEsBgI,GAEzC,GAAIU,EAAS,CACX,GAAIA,EAAQb,SACV,OAAOa,EACF,GAAIA,EAAQvC,MACjB,MAAO,CACLA,OAAO,EACPyB,aAAcc,EAAQd,cAIxB,IAAIc,EAAQN,aAGV,MAAM,IAAIvC,MAAM,8BAA8BnB,OAAO4D,KAAKC,UAAUG,EAAS,KAAM,KAFnFN,GAAe,CAKrB,CACF,CAEA,OAAIA,EACK,CACLA,cAAc,QAMlB,EAEF,IAAK,KACH,IAAK,IAA6DO,EAAzDC,EAAa,EAAgCb,EAAK9B,QAAiB0C,EAASC,KAAc7F,MAAO,CACxG,IAAI8F,EAAQF,EAAO3I,MAEnB,GAAI8H,EAAW,KAAOe,EACpB,OAA0B,IAAtBf,EAAWjJ,OACN,CACLsH,OAAO,EACPyB,aAAcE,GAIdE,EACK,CACLH,UAAU,GAIP,CACL1B,OAAO,EACPyB,aAAc,CAACiB,GAGrB,CAGA,OAIF,QACE,MAAM,IAAIhD,MAAM,iCAAiCnB,OAAOqD,IAE9D,C,qBC7PA,SAAS,EAAgCnG,EAAGC,GAAkB,IAAIC,EAAuB,oBAAXC,QAA0BH,EAAEG,OAAOC,WAAaJ,EAAE,cAAe,GAAIE,EAAI,OAAQA,EAAKA,EAAGG,KAAKL,IAAIM,KAAKC,KAAKL,GAAK,GAAIM,MAAMC,QAAQT,KAAOE,EAExN,SAAqCF,EAAGU,GAAU,IAAKV,EAAG,OAAQ,GAAiB,iBAANA,EAAgB,OAAO,EAAkBA,EAAGU,GAAS,IAAIE,EAAItD,OAAOwC,UAAUe,SAASR,KAAKL,GAAGH,MAAM,GAAI,GAAc,WAANe,GAAkBZ,EAAEc,cAAaF,EAAIZ,EAAEc,YAAYC,MAAM,GAAU,QAANH,GAAqB,QAANA,EAAa,OAAOJ,MAAMQ,KAAKhB,GAAI,GAAU,cAANY,GAAqB,2CAA2CK,KAAKL,GAAI,OAAO,EAAkBZ,EAAGU,EAAS,CAFlM,CAA4BV,KAAOC,GAAkBD,GAAyB,iBAAbA,EAAE/C,OAAqB,CAAMiD,IAAIF,EAAIE,GAAI,IAAIlD,EAAI,EAAG,OAAO,WAAc,OAAIA,GAAKgD,EAAE/C,OAAe,CAAEkE,MAAM,GAAe,CAAEA,MAAM,EAAO/C,MAAO4B,EAAEhD,KAAQ,CAAG,CAAE,MAAM,IAAIe,UAAU,wIAA0I,CAI3lB,SAAS,EAAkBqD,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAInE,UAAQoE,EAAMD,EAAInE,QAAQ,IAAK,IAAID,EAAI,EAAGsE,EAAO,IAAId,MAAMa,GAAMrE,EAAIqE,EAAKrE,IAAOsE,EAAKtE,GAAKoE,EAAIpE,GAAM,OAAOsE,CAAM,CAItL,SAAS,EAAkBxE,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAAa,CAAE,CAc5T,IAKIgK,EAA6BxF,EALf,IAEyB,IAMvCyF,EAAqC,OAUrCC,EAAuE,WACzE,MAAO,iBACT,EAOIC,EAAwE,WAC1E,MAAO,mBACT,EAoCIC,EAA8B,IAAI7F,OAAO,IAAM,IAAN,UAG9B,IAH8B,aAGU,IAHV,SASzC,EAAkC,WACpC,SAAS8F,EAAmB7J,GACdA,EAAK+E,MAAjB,IACIE,EAAWjF,EAAKiF,UA7FxB,SAAyB9E,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,oCAAwC,CA+FpJ,CAAgBE,KAAMsJ,GAEtBtJ,KAAK0E,SAAWA,EAChB1E,KAAKuJ,aACP,CA/FF,IAAsB1J,EAAaI,EAAYC,EA4tB7C,OA5tBoBL,EAiGPyJ,GAjGoBrJ,EAiGA,CAAC,CAChCV,IAAK,cACLY,MAAO,WACLH,KAAKwJ,kBAAehJ,EACpBR,KAAKyJ,cAAWjJ,EAChBR,KAAK0J,4BAAyBlJ,EAC9BR,KAAK2J,qCAAkCnJ,EACvCR,KAAK4J,yCAA2C,CAClD,GACC,CACDrK,IAAK,QACLY,MAAO,SAAe0J,EAAerF,GACnCxE,KAAKuJ,cAEDM,GACF7J,KAAK8J,OAAyC,MAAhCD,EAAcnJ,cAC5BV,KAAK+J,gBAAkBF,EAAcG,UAEjCxF,EAAM1D,2BACRd,KAAKiK,0BAA0BzF,KAGjCxE,KAAK8J,YAAStJ,EACdR,KAAK+J,gBAAkB,GAE3B,GAQC,CACDxK,IAAK,SACLY,MAAO,SAAgBwB,EAAY6C,GACjC,IH9HkC1D,EAA2B4D,EG8HzDwF,EAAQlK,KAgBZ,GH9IkCc,EG8IN0D,EAAM1D,0BH9I2B4D,EG8IA1E,KAAK0E,SH7IJ,gBAA3D,OAAAyF,EAAA,GAAkBrJ,EAA2B4D,GG8I9C,IAAK,IAAuEiE,EAAnEC,EAAY,EAAgC5I,KAAK+J,mBAA2BpB,EAAQC,KAAa1F,MAAO,CAC/G,IAAIuB,EAASkE,EAAMxI,MACfiK,EAA0B7F,EAAqBC,EAAOC,EAAQ,CAChEC,SAAU1E,KAAK0E,SACfC,sCAAuC,SAA+CF,GACpF,OAAOyF,EAAMvF,sCAAsCF,EAAQ,CACzDnE,cAAekE,EAAMlE,cACrBW,eAAgBuD,EAAMvD,gBAE1B,EACA2D,gCAAiC,SAAyCH,GACxE,OAAOyF,EAAMtF,gCAAgCH,EAC/C,IAGF,GAAI2F,EAQF,OAPApK,KAAKuJ,cACLvJ,KAAKwJ,aAAe/E,EACpBzE,KAAKqK,0BAA0BD,EAAwBE,QAAQ,MAAOhH,GAAoBkB,GAC1FxE,KAAK2J,gCAAkCS,EAGvCpK,KAAK4J,wCAA0C5J,KAAKyJ,SAASc,YAAYjH,GAClE8G,CAEX,CAKF,OAAOpK,KAAKwK,mCAAmC7I,EAAY6C,EAC7D,GAEC,CACDjF,IAAK,qCACLY,MAAO,SAA4CwB,EAAY6C,GAC7D,IAAIiG,EAAyBzK,KAAKwJ,aAE9BkB,EAAoB1K,KAAK2K,aAAanG,GAE1C,GAAIkG,EACF,OAAIA,IAAsBD,EAIjBzK,KAAK4K,+BAA+BjJ,GAMpC3B,KAAK4K,+BAA+BpG,EAAMzD,oBAGvD,GACC,CACDxB,IAAK,4BACLY,MAAO,SAAmC4E,GACxC,IAAI8F,EAAS7K,KAETc,EAA4BiE,EAAMjE,0BAClCG,EAAiB8D,EAAM9D,eACvBX,EAAgByE,EAAMzE,cACtBwK,EAAgBhK,EAYhBiK,EAA4BD,EAAc9L,OA7IpB,EA+ItB+L,EAA4B,IAC9BA,EAA4B,GAG9B/K,KAAK+J,gBAAkB/J,KAAK+J,gBAAgBiB,QAAO,SAAUvG,GAC3D,OAAOoG,EAAOI,YAAYxG,EAAQnE,EAAeW,IAAmB4J,EAAOK,cAAczG,EAAQqG,EAAeC,EAClH,IAQI/K,KAAKwJ,eAAqE,IAArDxJ,KAAK+J,gBAAgBzB,QAAQtI,KAAKwJ,eACzDxJ,KAAKuJ,aAET,GACC,CACDhK,IAAK,cACLY,MAAO,SAAqBsE,EAAQnE,EAAeW,GAWjD,QAAIA,IAAmBwD,EAAO0G,uBAC7B1G,EAAO2G,2DASH9K,IAAkBW,GAAkBwD,EAAO4G,0DAKlD,GACC,CACD9L,IAAK,gBACLY,MAAO,SAAuBsE,EAAQqG,EAAeC,GACnD,IAAIO,EAA6B7G,EAAO8G,wBAAwBvM,OAIhE,GAAmC,IAA/BsM,EACF,OAAO,EAOTP,EAA4BS,KAAKC,IAAIV,EAA2BO,EAA6B,GAC7F,IAAII,EAAuBjH,EAAO8G,wBAAwBR,GA0B1D,GAAID,EAAc9L,OAxOQ,EA6OxB,IACE,YAEOwB,IAFA,IAAI,EAAekL,GAAsBpF,MAAMwE,EAAe,CACnEjD,eAAe,GAWnB,CATE,MAAO8D,GAQP,OADAC,QAAQD,MAAMA,IACP,CACT,CASF,OAAO,IAAInI,OAAO,KAAKqB,OAAO6G,EAAsB,MAAM1I,KAAK8H,EACjE,GACC,CACDvL,IAAK,kBACLY,MAAO,SAAyBsE,EAAQnE,GACtC,OAAOA,EAAgBmE,EAAOoH,sBAAwBpH,EAAOA,QAC/D,GACC,CACDlF,IAAK,eACLY,MAAO,SAAsBqE,GAoF3B,IAnFA,IAmFqFsE,EAnFjFgD,EAAS9L,KAET+L,EAAQ,WACV,IAAItH,EAASqE,EAAO3I,MAIpB,OAAI2L,EAAOtC,eAAiB/E,EACnB,QA2CJ4E,EAA4BrG,KAAK8I,EAAOE,gBAAgBvH,EAAQD,EAAMlE,gBAItEwL,EAAOG,wBAAwBxH,EAAQD,IAQ5CsH,EAAOtC,aAAe/E,EACf,UAPLqH,EAAO/B,gBAAkB+B,EAAO/B,gBAAgBiB,QAAO,SAAUkB,GAC/D,OAAOA,IAAMzH,CACf,IACO,YARA,UAaX,EAkBSsE,EAAa,EAAgC/I,KAAK+J,gBAAgBnI,WAAoBkH,EAASC,KAAc7F,MAAO,CAC3H,IAAIiJ,EAAOJ,IAEX,GAAa,UAATI,EAAkB,KAExB,CAOA,OALKnM,KAAKwJ,cAERxJ,KAAKuJ,cAGAvJ,KAAKwJ,YACd,GACC,CACDjK,IAAK,0BACLY,MAAO,SAAiCsE,EAAQD,GAM9C,KAA0CC,EAAOK,UAAUwD,QAAQ,MAAQ,GAA3E,CAKA,IAAImB,SAAWzJ,KAAKoM,qBAAqB3H,EAAQD,GAGjD,OAAIiF,UACFzJ,KAAKqK,0BAA0BZ,SAAUjF,IAClC,QAFT,CANA,CAUF,GACC,CACDjF,IAAK,kCACLY,MAAO,SAAyCsE,GAM9C,OAAIzE,KAAK8J,QAQLrF,GAAUA,EAAO4H,gCAAkCnD,EAAmClG,KAAKyB,EAAO4H,gCAP7F,IAcF,EACT,GACC,CACD9M,IAAK,iDACLY,MAAO,SAAwDiF,EAAOkH,GACpE,IAAI/L,EAAY6E,EAAM7E,UAClBE,EAAc2E,EAAM3E,YAExB,OAAIF,EACK+L,IAA+B,IAApBA,EAAQC,QAAoBhM,EAAYA,EAAY,IAGpEE,EACK,GAGF,GACT,GACC,CACDlB,IAAK,cACLY,MAAO,SAAqBqE,GAC1B,GAAKxE,KAAKyJ,SAAV,CAaA,IANA,IAAIpF,GAAS,EACTtF,EAAI,EACJyN,EAAsBhI,EAAMlE,cAAgBN,KAAKyM,+CAA+CjI,EAAO,CACzG+H,SAAS,IACN,GAEExN,EAAIyN,EAAoBxN,OAASwF,EAAMkI,sCAAsC1N,QAClFqF,EAAQrE,KAAKyJ,SAASnB,QAAQhF,EAAmBe,EAAQ,GACzDtF,IAGF,OAAO8E,EAA2B7D,KAAKyJ,SAAUpF,EAAQ,EAhBzD,CAiBF,GACC,CACD9E,IAAK,4BACLY,MAAO,SAAmCsJ,SAAUjF,GAClDxE,KAAK0J,uBAAyBD,SAC9BzJ,KAAK2J,gCAAkCF,SAGvCzJ,KAAK4J,yCAA2C,EAM5CpF,EAAMlE,cACRN,KAAKyJ,SAAWzJ,KAAKyM,+CAA+CjI,GAAO8F,QAAQ,UAAWhH,GAAqBG,EAAOH,EAAmBkB,EAAM9D,YAAY1B,QAAU,IAAMyK,SAE/KzJ,KAAKyJ,SAAWA,QAEpB,GASC,CACDlK,IAAK,uBACLY,MAAO,SAA8BsE,EAAQkI,GAC3C,IAAI7L,EAA4B6L,EAAM7L,0BAClCR,EAAgBqM,EAAMrM,cACtBW,EAAiB0L,EAAM1L,eACvBE,EAA+CwL,EAAMxL,6CACrD2D,QAAUL,EAAOK,UAInBA,QAAUA,QACTwF,QAAQnB,IAAkC,OAC1CmB,QAAQlB,IAAmC,OAW9C,IAAIzI,EAASsI,EAA2B3C,MAAMxB,SAAS,GAGvD,KAAIhE,EAA0B9B,OAAS2B,EAAO3B,QAA9C,CAiCA,IAAI4N,EAAgB,IAAIpJ,OAAO,IAAMsB,QAAU,KAC3C+H,EAA4B/L,EAA0BwJ,QAAQ,MAnmBtD,KAumBRsC,EAAc5J,KAAK6J,KACrBlM,EAASkM,GAGX,IACIC,EADAC,EAAe/M,KAAKgM,gBAAgBvH,EAAQnE,GAShD,GAAIN,KAAK2E,sCAAsCF,EAAQ,CACrDnE,cAAeA,EACfW,eAAgBA,IACd,CACF,IAAI+L,EAAiCD,EAAazC,QAAQ,IAAqB7F,EAAO4H,gCAUtF,GAAI,OAAA5G,EAAA,GAAYhB,EAAO4H,mCAAqCpL,GAAkB,IAAM,OAAAwE,EAAA,GAAY,QAC9FsH,EAAeC,EACfF,GAAmC,EAG/B7L,GAGF,IAFA,IAAIlC,EAAIkC,EAAejC,OAEhBD,EAAI,GACTgO,EAAeA,EAAazC,QAAQ,KAAMhH,GAC1CvE,GAIR,CAGA,IAAI0K,SAAW9I,EACd2J,QAAQ,IAAI9G,OAAOsB,SAAUiI,GAC7BzC,QAAQ,IAAI9G,OArpBD,IAqpBqB,KAAMF,GAmBvC,OAdKwJ,IACC3L,EAEFsI,SAAWhG,EAAOH,EAAmBnC,EAA6CnC,QAAU,IAAMyK,SACzFxI,IAETwI,SAAWhG,EAAOH,EAAmBrC,EAAejC,QAAUgB,KAAK4E,gCAAgCH,GAAUgF,WAI7GnJ,IACFmJ,SAAW,OAAAwD,EAAA,GAAiCxD,WAGvCA,QArGP,CAsGF,GACC,CACDlK,IAAK,iCACLY,MAAO,SAAwCQ,GAC7C,IAAIiD,EJjmBH,SAAoC6F,SAAUyD,EAAUvM,GAM7D,IAAK,IAAoEmI,EAAhEC,EAAajH,EAAgCnB,EAAOsG,MAAM,OAAgB6B,EAASC,KAAc7F,MAAO,CAC/G,IAAIiK,EAAQrE,EAAO3I,MAMnB,GAAIsJ,SAAS7H,MAAMsL,EAAW,GAAGE,OAAO7J,GAA6B,EACnE,OAGF2J,EAAWzD,SAAS2D,OAAO7J,GAC3BkG,SAAWA,SAASa,QAAQ/G,EAA2B4J,EACzD,CAEA,MAAO,CAAC1D,SAAUyD,EACpB,CI2kBmBG,CAA2BrN,KAAK2J,gCAAiC3J,KAAK4J,wCAAyCjJ,GAE5H,GAAKiD,EASL,OAHA5D,KAAK2J,gCAAkC/F,EAAO,GAC9C5D,KAAK4J,wCAA0ChG,EAAO,GAE/CC,EAA2B7D,KAAK2J,gCAAiC3J,KAAK4J,wCAA0C,GAPrH5J,KAAKuJ,aAWT,GACC,CACDhK,IAAK,wCACLY,MAAO,SAA+CsE,EAAQ6I,GAC5D,IAAIhN,EAAgBgN,EAAMhN,cACtBW,EAAiBqM,EAAMrM,eAE3B,GAAIwD,EAAO4H,+BAAgC,CAIzC,IAAIlB,EAAqB1G,EAAO0G,qBAEhC,GAAIA,GAAsBlK,IAAmBkK,IAAuB7K,EAClE,OAAO,CAEX,CACF,MAztB0E,EAAkBT,EAAYgC,UAAW5B,GAAiBC,GAAa,EAAkBL,EAAaK,GAAcb,OAAOC,eAAeO,EAAa,YAAa,CAAET,UAAU,IA4tBrPkK,CACT,CAvoBsC,G,oCChGtC,SAASiE,EAAepK,EAAKpE,GAAK,OAUlC,SAAyBoE,GAAO,GAAIZ,MAAMC,QAAQW,GAAM,OAAOA,CAAK,CAV3BqK,CAAgBrK,IAQzD,SAA+BA,EAAKpE,GAAK,IAAIsC,EAAY,MAAP8B,EAAc,KAAyB,oBAAXjB,QAA0BiB,EAAIjB,OAAOC,WAAagB,EAAI,cAAe,GAAU,MAAN9B,EAAY,OAAQ,IAAkDoM,EAAIC,EAAlDC,EAAO,GAAQC,GAAK,EAAUC,GAAK,EAAmB,IAAM,IAAKxM,EAAKA,EAAGe,KAAKe,KAAQyK,GAAMH,EAAKpM,EAAGgB,QAAQa,QAAoByK,EAAK3J,KAAKyJ,EAAGtN,QAAYpB,GAAK4O,EAAK3O,SAAWD,GAA3D6O,GAAK,GAA0M,CAAtI,MAAOE,GAAOD,GAAK,EAAMH,EAAKI,CAAK,CAAE,QAAU,IAAWF,GAAsB,MAAhBvM,EAAW,QAAWA,EAAW,QAAmC,CAA5B,QAAU,GAAIwM,EAAI,MAAMH,CAAI,CAAE,CAAE,OAAOC,CAAM,CAR/bI,CAAsB5K,EAAKpE,IAI5F,SAAqCgD,EAAGU,GAAU,IAAKV,EAAG,OAAQ,GAAiB,iBAANA,EAAgB,OAAO,GAAkBA,EAAGU,GAAS,IAAIE,EAAItD,OAAOwC,UAAUe,SAASR,KAAKL,GAAGH,MAAM,GAAI,GAAc,WAANe,GAAkBZ,EAAEc,cAAaF,EAAIZ,EAAEc,YAAYC,MAAM,GAAU,QAANH,GAAqB,QAANA,EAAa,OAAOJ,MAAMQ,KAAKhB,GAAI,GAAU,cAANY,GAAqB,2CAA2CK,KAAKL,GAAI,OAAO,GAAkBZ,EAAGU,EAAS,CAJ7T,CAA4BU,EAAKpE,IAEnI,WAA8B,MAAM,IAAIe,UAAU,4IAA8I,CAFvDkO,EAAoB,CAM7J,SAAS,GAAkB7K,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAInE,UAAQoE,EAAMD,EAAInE,QAAQ,IAAK,IAAID,EAAI,EAAGsE,EAAO,IAAId,MAAMa,GAAMrE,EAAIqE,EAAKrE,IAAOsE,EAAKtE,GAAKoE,EAAIpE,GAAM,OAAOsE,CAAM,CAQtL,SAAS,GAAkBxE,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAAa,CAAE,CAU5T,IAAIgP,GAA2C,IAAM,IAAoB,IAAe,KACpFC,GAAmD,IAAI1K,OAAO,IAAMyK,GAA2C,IAAK,KACpHE,GAAoC,OAAc,IAAd,KAAuC,IAAoB,IAA3D,OAA6F,IAAoB,IAAjH,MACpCC,GAAwC,IAAI5K,OAAO,KAAO,IAAoB,IAA3B,SAInD6K,GAA0B,YAE1B,GAA+B,WACjC,SAASC,EAAgB7O,GACvB,IAAIW,EAAiBX,EAAKW,eACtBC,EAAqBZ,EAAKY,mBAC1BqE,EAAWjF,EAAKiF,SAChB6J,EAAoC9O,EAAK8O,mCA1BjD,SAAyB3O,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,oCAAwC,CA4BpJ,CAAgBE,KAAMsO,GAEtBtO,KAAKI,eAAiBA,EACtBJ,KAAKK,mBAAqBA,EAC1BL,KAAK0E,SAAWA,EAChB1E,KAAKuO,kCAAoCA,CAC3C,CA9BF,IAAsB1O,EAAaI,EAAYC,EA8Z7C,OA9ZoBL,EAgCPyO,GAhCoBrO,EAgCH,CAAC,CAC7BV,IAAK,QACLY,MAAO,SAAeqO,KAAMhK,GAC1B,IAOIiK,EAPAC,EAybH,SAAuCF,MAC5C,IACIG,EAAyBpB,EAnB/B,SAAwCiB,MAEtC,IAAII,EApCN,SAAqCJ,MAEnC,IASIK,EATAC,EAAWN,KAAKpB,OAAOe,IAE3B,KAAIW,EAAW,GAqBf,MAZgB,OAJhBN,KAAOA,KAAK5M,MAAMkN,IAIT,KACPD,GAAU,EACVL,KAAOA,KAAK5M,MAAM,IAAI5C,SAIxBwP,KAAOA,KAAKlE,QAAQ8D,GAAuC,IAEvDS,IACFL,KAAO,IAAMA,MAGRA,IACT,CAUwBO,CAA4BP,OAAS,GAE3D,MAA2B,MAAvBI,EAAgB,GACX,CAACA,EAAgBhN,MAAM,IAAI5C,SAAS,GAGtC,CAAC4P,EACV,CAS+BI,CAA+BR,MACQ,GAChES,EAAkBN,EAAuB,GACzCE,EAAUF,EAAuB,GASrC,OAJKT,GAAiDlL,KAAKiM,KACzDA,EAAkB,IAGb,CAACA,EAAiBJ,EAC3B,CAvckCK,CAA8BV,MACtDW,EAAyB5B,EAAemB,EAAuB,GAC/DO,EAAkBE,EAAuB,GACzCN,EAAUM,EAAuB,GAEjCxO,EAAS,OAAA8E,EAAA,GAAYwJ,GAkBzB,OAdIJ,IACGrK,EAAM7D,SACT6D,EAAM4K,2BAEDzO,IACH8N,GAAkB,KAKpB9N,GACFX,KAAKqP,YAAY1O,EAAQ6D,GAGpB,CACL7D,OAAQA,EACR8N,gBAAiBA,EAErB,GAOC,CACDlP,IAAK,cACLY,MAAO,SAAqBwB,EAAY6C,GACtC,IAAI7D,EAAS6D,EAAM7D,OACf2O,EAAgC3O,EAAO3B,OAAS,GAAK2B,EAAO3B,OAAS2C,EAAW3C,QAAU,EAqB9F,GAnBAwF,EAAM+K,aAAa5N,GAef2N,GACFtP,KAAKwP,iBAAiBhL,GAGpBxE,KAAKyP,+BAA+BjL,IACtC,IAAKxE,KAAK0P,0BAA0BlL,GAClC,YAGFA,EAAMmL,sCAAsChO,GAQzC6C,EAAMlE,eACJN,KAAK4P,uCACR5P,KAAK6P,iCAAiCrL,EAAMzD,qBAAqB,SAAU+O,GACzE,OAAOtL,EAAMuL,OAAOD,EACtB,GAGN,GACC,CACDvQ,IAAK,iCACLY,MAAO,SAAwC4E,GAC7C,IAAIzE,EAAgByE,EAAMzE,cACtBI,EAAcqE,EAAMrE,YACxB,OAAOJ,IAAkBI,CAC3B,GAGC,CACDnB,IAAK,4BACLY,MAAO,SAAmCqE,GACxC,IAAIwL,EAAwB,YAA2B,IAAMxL,EAAMkI,sCAAuC1M,KAAKI,eAAgBJ,KAAKK,mBAAoBL,KAAK0E,SAASA,UAClKuL,EAAqBD,EAAsBC,mBAC3CC,EAASF,EAAsBE,OAEnC,GAAID,EAKF,OAJAzL,EAAM9C,eAAeuO,GACrBzL,EAAMuL,OAAO,CACXjP,0BAA2BoP,KAEtB,CAEX,GACC,CACD3Q,IAAK,QACLY,MAAO,SAAe0J,GACpB,GAAIA,EAAe,CACjB7J,KAAKmQ,0BAA2B,EAEhC,IAAIC,EAA2BvG,EAAcwG,4BAE7CrQ,KAAKsQ,qDAAuDF,GAA4B/B,GAAwBrL,KAAKoN,EACvH,MACEpQ,KAAKmQ,8BAA2B3P,EAChCR,KAAKsQ,0DAAuD9P,CAEhE,GASC,CACDjB,IAAK,mCACLY,MAAO,SAA0CoQ,EAAgBC,GAC/D,GAAKxQ,KAAKmQ,yBAAV,CAIA,IAAIM,EAAwB,OAAAC,EAAA,GAAkDH,EAAgBvQ,KAAK0E,UAC/FzD,EAAiBwP,EAAsBxP,eACvC0P,EAAiBF,EAAsBE,eACvCzP,EAAcuP,EAAsBvP,YAExC,GAAIyP,IAAmBJ,EAKvB,OADAvQ,KAAK4Q,0BAA0B3P,EAAgBC,EAAayP,EAAgBJ,EAAgBC,IACrF,CAZP,CAaF,GAOC,CACDjR,IAAK,0CACLY,MAAO,SAAiDoQ,EAAgBM,EAA+BL,GACrG,IAAKxQ,KAAK4P,sCACR,OAAO5P,KAAK6P,iCAAiCU,EAAgBC,GAG/D,GAAKxQ,KAAKsQ,qDAAV,CAIA,IAAIQ,EAAyB,OAAAJ,EAAA,GAAkDH,EAAgBvQ,KAAK0E,UAChGzD,EAAiB6P,EAAuB7P,eACxC0P,EAAiBG,EAAuBH,eACxCzP,EAAc4P,EAAuB5P,YASzC,GAAIyP,IAAmBE,EAKvB,OADA7Q,KAAK4Q,0BAA0B3P,EAAgBC,EAAayP,EAAgBJ,EAAgBC,IACrF,CAnBP,CAoBF,GACC,CACDjR,IAAK,4BACLY,MAAO,SAAmCc,EAAgBC,EAAaJ,EAA2ByP,EAAgBC,GAChH,IAAIrP,EACAH,EAEA+P,EAAiCR,EAAehG,YAAYzJ,GAMhE,GAAIiQ,GAAkC,GAAKA,IAAmCR,EAAevR,OAAS8B,EAA0B9B,OAAQ,CACtIgC,GAAwC,EAMxC,IAAIgQ,EAA6BT,EAAe3O,MAAM,EAAGmP,GAMrDC,IAA+B/P,IACjCE,EAA+C6P,EAEnD,CAEAR,EAAS,CACPvP,eAAgBA,EAChBC,YAAaA,EACbJ,0BAA2BA,EAC3BE,sCAAuCA,EACvCG,6CAA8CA,IAIhDnB,KAAK4P,uCAAwC,EAC7C5P,KAAKuO,mCACP,GACC,CACDhP,IAAK,qCACLY,MAAO,SAA4CqE,GAkCjD,QAAIxE,KAAKiR,wCAAwCzM,EAAMzD,oBAAqByD,EAAM1D,2BAA2B,SAAUgP,GACrH,OAAOtL,EAAMuL,OAAOD,EACtB,MAkBI9P,KAAKwP,iBAAiBhL,IAYtBxE,KAAKkR,eAAe1M,IAXtBxE,KAAKmR,+CAA+C3M,IAC7C,QAUT,EAIF,GACC,CACDjF,IAAK,mBACLY,MAAO,SAA0BqE,GAG/B,IAAIlE,EAAgBkE,EAAMlE,cACtBC,EAAYiE,EAAMjE,UAClBI,EAAS6D,EAAM7D,OAGnB,GAFgC6D,EAAM1D,2BAElCR,IAAiBC,EAArB,CAQA,IAAI6Q,EAAmB,OAAAC,EAAA,GAAe1Q,EAAQX,KAAKI,eAAgBJ,KAAKK,mBAAoBL,KAAK0E,SAASA,UAE1G,YAAyBlE,IAArB4Q,GAAkCA,IAAqBzQ,GAGzD6D,EAAMuL,OAAO,CACXxP,UAAWI,EAAOiB,MAAM,EAAGjB,EAAO3B,OAASoS,EAAiBpS,UAE9DgB,KAAKoP,yBAAyB5K,EAAO,CACnChD,aAAShB,EACTE,iBAAaF,KAER,QAVT,CARA,CAoBF,GACC,CACDjB,IAAK,iBACLY,MAAO,SAAwBqE,GAC7B,IAAKA,EAAMlE,cAAe,CACxB,IAAIgR,EAAyB,OAAAC,EAAA,GAAgE/M,EAAM7D,OAAQX,KAAKI,eAAgBJ,KAAKK,mBAAoBL,KAAK0E,SAASA,UACnK8M,EAAiBF,EAAuBrB,mBAG5C,GAFaqB,EAAuBpB,OAEhCsB,EAQF,OAPAhN,EAAMuL,OAAO,CACXtP,aAAa,IAEfT,KAAKoP,yBAAyB5K,EAAO,CACnChD,QAASgD,EAAMhD,QACfd,YAAa8Q,KAER,CAEX,CACF,GACC,CACDjS,IAAK,2BACLY,MAAO,SAAkCqE,EAAOY,GAC9C,IAAI5D,EAAU4D,EAAM5D,QAChBd,EAAc0E,EAAM1E,YACxB8D,EAAM4K,yBAAyB5N,EAASd,GAEpC8D,EAAM1D,4BACR0D,EAAM5D,iCACNZ,KAAKuO,oCACLvO,KAAK4P,2CAAwCpP,EAEjD,GACC,CACDjB,IAAK,iDACLY,MAAO,SAAwDqE,GACzDxE,KAAK0P,0BAA0BlL,IAOjCxE,KAAK6P,iCAAiCrL,EAAMzD,qBAAqB,SAAU+O,GACzE,OAAOtL,EAAMuL,OAAOD,EACtB,GAEJ,MA3Z0E,GAAkBjQ,EAAYgC,UAAW5B,GAAiBC,GAAa,GAAkBL,EAAaK,GAAcb,OAAOC,eAAeO,EAAa,YAAa,CAAET,UAAU,IA8ZrPkP,CACT,CA9YmC,G,cCjCnC,SAASmD,GAAQC,GAAkC,OAAOD,GAAU,mBAAqBvP,QAAU,iBAAmBA,OAAOC,SAAW,SAAUuP,GAAO,cAAcA,CAAK,EAAI,SAAUA,GAAO,OAAOA,GAAO,mBAAqBxP,QAAUwP,EAAI7O,cAAgBX,QAAUwP,IAAQxP,OAAOL,UAAY,gBAAkB6P,CAAK,EAAGD,GAAQC,EAAM,CAE/U,SAAS,GAAevO,EAAKpE,GAAK,OAUlC,SAAyBoE,GAAO,GAAIZ,MAAMC,QAAQW,GAAM,OAAOA,CAAK,CAV3B,CAAgBA,IAQzD,SAA+BA,EAAKpE,GAAK,IAAIsC,EAAY,MAAP8B,EAAc,KAAyB,oBAAXjB,QAA0BiB,EAAIjB,OAAOC,WAAagB,EAAI,cAAe,GAAU,MAAN9B,EAAY,OAAQ,IAAkDoM,EAAIC,EAAlDC,EAAO,GAAQC,GAAK,EAAUC,GAAK,EAAmB,IAAM,IAAKxM,EAAKA,EAAGe,KAAKe,KAAQyK,GAAMH,EAAKpM,EAAGgB,QAAQa,QAAoByK,EAAK3J,KAAKyJ,EAAGtN,QAAYpB,GAAK4O,EAAK3O,SAAWD,GAA3D6O,GAAK,GAA0M,CAAtI,MAAOE,GAAOD,GAAK,EAAMH,EAAKI,CAAK,CAAE,QAAU,IAAWF,GAAsB,MAAhBvM,EAAW,QAAWA,EAAW,QAAmC,CAA5B,QAAU,GAAIwM,EAAI,MAAMH,CAAI,CAAE,CAAE,OAAOC,CAAM,CAR/b,CAAsBxK,EAAKpE,IAI5F,SAAqCgD,EAAGU,GAAU,IAAKV,EAAG,OAAQ,GAAiB,iBAANA,EAAgB,OAAO,GAAkBA,EAAGU,GAAS,IAAIE,EAAItD,OAAOwC,UAAUe,SAASR,KAAKL,GAAGH,MAAM,GAAI,GAAc,WAANe,GAAkBZ,EAAEc,cAAaF,EAAIZ,EAAEc,YAAYC,MAAM,GAAU,QAANH,GAAqB,QAANA,EAAa,OAAOJ,MAAMQ,KAAKhB,GAAI,GAAU,cAANY,GAAqB,2CAA2CK,KAAKL,GAAI,OAAO,GAAkBZ,EAAGU,EAAS,CAJ7T,CAA4BU,EAAKpE,IAEnI,WAA8B,MAAM,IAAIe,UAAU,4IAA8I,CAFvD,EAAoB,CAM7J,SAAS,GAAkBqD,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAInE,UAAQoE,EAAMD,EAAInE,QAAQ,IAAK,IAAID,EAAI,EAAGsE,EAAO,IAAId,MAAMa,GAAMrE,EAAIqE,EAAKrE,IAAOsE,EAAKtE,GAAKoE,EAAIpE,GAAM,OAAOsE,CAAM,CAQtL,SAAS,GAAkBxE,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAAa,CAAE,CAU5T,IAEI,GAAyB,WAK3B,SAAS0S,EAAUC,EAAyBlN,IAnB9C,SAAyB9E,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,oCAAwC,CAoBpJ,CAAgBE,KAAM2R,GAEtB3R,KAAK0E,SAAW,IAAI,IAASA,GAE7B,IACImN,EAAyB,GADD7R,KAAK8R,yBAAyBF,GACS,GAC/DxR,EAAiByR,EAAuB,GACxCxR,EAAqBwR,EAAuB,GAEhD7R,KAAKI,eAAiBA,EACtBJ,KAAKK,mBAAqBA,EAC1BL,KAAK+R,OACP,CA5BF,IAAsBlS,EAAaI,EAAYC,EAsd7C,OAtdoBL,EA8BP8R,GA9BoB1R,EA8BT,CAAC,CACvBV,IAAK,2BACLY,MAAO,SAAkCyR,GAEvC,IAAIxR,EACAC,EAwBJ,OAtBIuR,IACuC,WAArCH,GAAQG,IACVxR,EAAiBwR,EAAwBxR,eACzCC,EAAqBuR,EAAwBvR,oBAE7CD,EAAiBwR,GAIjBxR,IAAmBJ,KAAK0E,SAASsN,WAAW5R,KAC9CA,OAAiBI,GAYZ,CAACJ,EAAgBC,EAC1B,GAOC,CACDd,IAAK,QACLY,MAAO,SAAeqO,MACpB,IAAIyD,EAAqBjS,KAAKkS,OAAOC,MAAM3D,KAAMxO,KAAKwE,OAClD7D,EAASsR,EAAmBtR,OAGhC,GAFsBsR,EAAmBxD,gBAGvCzO,KAAKoS,gBAAkB,SAClB,GAAIzR,EAAQ,CAOjB,IAAI0E,EAMJ,GAZArF,KAAKqS,8BAEDrS,KAAKwE,MAAM1D,2BACbd,KAAKsS,UAAUrI,0BAA0BjK,KAAKwE,OAK5CxE,KAAK0E,SAASyL,6BAChB9K,EAA0BrF,KAAKsS,UAAU7N,OAAO9D,EAAQX,KAAKwE,aAG/BhE,IAA5B6E,GAEErF,KAAKkS,OAAOK,mCAAmCvS,KAAKwE,OAAQ,CAC9DxE,KAAKqS,8BAEL,IAAI9B,EAAiBvQ,KAAKwE,MAAMzD,oBAE5BwP,IACFlL,EAA0BrF,KAAKsS,UAAU7N,OAAO8L,EAAgBvQ,KAAKwE,OAEzE,CAGFxE,KAAKoS,gBAAkB/M,EAA0BrF,KAAKwS,cAAcnN,GAA2BrF,KAAKyS,uBACtG,CAEA,OAAOzS,KAAKoS,eACd,GACC,CACD7S,IAAK,QACLY,MAAO,WACL,IAAI+J,EAAQlK,KAoCZ,OAlCAA,KAAKwE,MAAQ,IAAIhF,EAAe,CAC9BE,gBAAiB,SAAyB8B,GAMxC0I,EAAM1I,QAAUA,CAClB,EACA7B,oBAAqB,SAA6Be,EAAac,GAC7D0I,EAAMxF,SAASgO,oBAAoBlR,EAASd,GAE5CwJ,EAAMoI,UAAUP,MAAM7H,EAAMxF,SAASmF,cAAeK,EAAM1F,OAE1D0F,EAAMgI,OAAOH,MAAM7H,EAAMxF,SAASmF,cACpC,IAEF7J,KAAKsS,UAAY,IAAI,EAAmB,CACtC9N,MAAOxE,KAAKwE,MACZE,SAAU1E,KAAK0E,WAEjB1E,KAAKkS,OAAS,IAAI,GAAgB,CAChC9R,eAAgBJ,KAAKI,eACrBC,mBAAoBL,KAAKK,mBACzBqE,SAAU1E,KAAK0E,SACfF,MAAOxE,KAAKwE,MACZ+J,kCAAmC,WACjCrE,EAAMmI,8BAENnI,EAAMoI,UAAUP,MAAM7H,EAAMxF,SAASmF,cAAeK,EAAM1F,MAC5D,IAEFxE,KAAKwE,MAAMuN,MAAM/R,KAAKI,eAAgBJ,KAAKK,oBAC3CL,KAAKoS,gBAAkB,GAChBpS,IACT,GAOC,CACDT,IAAK,kBACLY,MAAO,WACL,OAAOH,KAAKwE,MAAMlE,aACpB,GAQC,CACDf,IAAK,iBACLY,MAAO,WASL,GAAIH,KAAK2S,kBACP,OAAO3S,KAAKwE,MAAM9D,WAEtB,GAEC,CACDnB,IAAK,wBACLY,MAAO,WACL,OAAOH,KAAK4S,gBACd,GAQC,CACDrT,IAAK,aACLY,MAAO,WAGL,GAFaH,KAAKwE,MAAM7D,OAGtB,OAAOX,KAAK6S,aAEhB,GAOC,CACDtT,IAAK,cACLY,MAAO,WACL,IAAIqB,EAAUxB,KAAKwE,MAAMhD,QAWzB,OAAOA,CACT,GACC,CACDjC,IAAK,8BACLY,MAAO,WAiBAH,KAAKwE,MAAMhD,UAAWxB,KAAK8S,iCAC9B9S,KAAK+S,qBAET,GAEC,CACDxT,IAAK,gBACLY,MAAO,SAAuBkF,GAC5B,IAAIwF,EAAS7K,KAEb,GAAIA,KAAK2S,kBAAmB,CAC1B,IAAIK,EAAS,SAAgBxE,MAC3B,OAAO3D,EAAOyH,UAAU7F,+CAA+C5B,EAAOrG,MAAO,CACnF+H,UAASiC,OACNA,IACP,EAEI9N,EAAcV,KAAKwE,MAAM9D,YAE7B,OAQOsS,EARFtS,EAIA2E,EAIS,GAAGR,OAAOnE,EAAa,KAAKmE,OAAOQ,GAHjC3E,EAJA,GAAGmE,OAAO7E,KAAKwE,MAAMkI,uCAQvC,CAEA,OAAOrH,CACT,GACC,CACD9F,IAAK,0CACLY,MAAO,WACL,IAAI8S,EAAcjT,KAAKwE,MACnB1D,EAA4BmS,EAAYnS,0BACxCK,EAA+C8R,EAAY9R,6CAC3DF,EAAiBgS,EAAYhS,eAC7BiP,EAASpP,EACTkS,EAAS7R,GAAgDF,EAM7D,OAJI+R,IACF9C,EAAS8C,EAAS9C,GAGbA,CACT,GACC,CACD3Q,IAAK,wBACLY,MAAO,WACL,IAAIa,EAAwChB,KAAKwE,MAAMxD,sCACvD,OAAOhB,KAAKwS,cAAcxR,EAAwChB,KAAKkT,0CAA4ClT,KAAKwE,MAAMzD,oBAChI,GACC,CACDxB,IAAK,0BACLY,MAAO,WACL,IAAI+P,EAASlQ,KAAKyS,wBAElB,GAAIvC,EACF,OAAOA,EAAO5F,QAAQ,UAAWhH,EAErC,GACC,CACD/D,IAAK,gCACLY,MAAO,WACL,IAAIO,EAAcV,KAAKwE,MAAM9D,YACzByS,EAAenT,KAAK0E,SAAS0O,8BAA8B1S,GAC/D,OAAOyS,GAAgBA,EAAanU,OAAS,CAC/C,GAIC,CACDO,IAAK,sBACLY,MAAO,WACLH,KAAKwE,MAAM/C,WAAW,OAAA4R,GAAA,GAAwBrT,KAAK2S,kBAAoB3S,KAAKwE,MAAM9D,YAAcV,KAAKK,mBAAoBL,KAAKwE,MAAM1D,0BAA2Bd,KAAK0E,UACtK,GAoBC,CACDnF,IAAK,iBACLY,MAAO,WACL,IAAImT,EAAetT,KAAKwE,MACpB7D,EAAS2S,EAAa3S,OACtBD,EAAc4S,EAAa5S,YAC3Bc,EAAU8R,EAAa9R,QACvBV,EAA4BwS,EAAaxS,0BAE7C,GAAKH,EAIL,OAAIX,KAAK2S,kBACHjS,EACK,IAAMA,EAAcI,EAEpB,IAAMH,EAGXa,GAAWd,EAEN,KADYc,EAAUxB,KAAK0E,SAASuL,qBAAuBvP,GACtCI,OAF9B,CAKJ,GAQC,CACDvB,IAAK,YACLY,MAAO,WACL,IAAIoT,EAAevT,KAAKwE,MACpB1D,EAA4ByS,EAAazS,0BACzCI,EAAcqS,EAAarS,YAC3BR,EAAc6S,EAAa7S,YAI3Bc,EAAUxB,KAAK6S,cAEnB,GAAK/R,IAIAU,GAAYd,GAAjB,CAIA,IAAI8S,EAAc,IAAIC,EAAA,EAAYjS,GAAWd,EAAaI,EAA2Bd,KAAK0E,SAASA,UAOnG,OALIxD,IACFsS,EAAYtS,YAAcA,GAIrBsS,CATP,CAUF,GAOC,CACDjU,IAAK,aACLY,MAAO,WACL,IAAIqT,EAAcxT,KAAK0T,YAEvB,QAAKF,GAIEA,EAAYG,YACrB,GAOC,CACDpU,IAAK,UACLY,MAAO,WACL,IAAIqT,EAAcxT,KAAK0T,YAEvB,QAAKF,GAIEA,EAAYI,SACrB,GAOC,CACDrU,IAAK,oBACLY,MAAO,WACL,OAAOH,KAAKwE,MAAM1D,yBACpB,GAMC,CACDvB,IAAK,WACLY,MAAO,WACL,OAAQH,KAAKwE,MAAMlE,cAAgB,IAAM,IAAMN,KAAKwE,MAAM7D,MAC5D,GAMC,CACDpB,IAAK,cACLY,MAAO,WACL,OAAOH,KAAKsS,UAAUuB,YAAY7T,KAAKwE,QAAUxE,KAAK8T,2BAA6B,EACrF,MAnd0E,GAAkBjU,EAAYgC,UAAW5B,GAAiBC,GAAa,GAAkBL,EAAaK,GAAcb,OAAOC,eAAeO,EAAa,YAAa,CAAET,UAAU,IAsdrPuS,CACT,CA7c6B,GCtBtB,SAAS,GAAUnQ,GACzB,OAAO,GAAWY,KAAKpC,KAAMwB,EAAS,IACvC,CAEA,GAAUK,UAAYxC,OAAO0U,OAAO,GAAWlS,UAAW,CAAC,GAC3D,GAAUA,UAAUgB,YAAc,E","file":"38970f4.js","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar AsYouTypeState = /*#__PURE__*/function () {\n  function AsYouTypeState(_ref) {\n    var onCountryChange = _ref.onCountryChange,\n        onCallingCodeChange = _ref.onCallingCodeChange;\n\n    _classCallCheck(this, AsYouTypeState);\n\n    this.onCountryChange = onCountryChange;\n    this.onCallingCodeChange = onCallingCodeChange;\n  }\n\n  _createClass(AsYouTypeState, [{\n    key: \"reset\",\n    value: function reset(defaultCountry, defaultCallingCode) {\n      this.international = false;\n      this.IDDPrefix = undefined;\n      this.missingPlus = undefined;\n      this.callingCode = undefined;\n      this.digits = '';\n      this.resetNationalSignificantNumber();\n      this.initCountryAndCallingCode(defaultCountry, defaultCallingCode);\n    }\n  }, {\n    key: \"resetNationalSignificantNumber\",\n    value: function resetNationalSignificantNumber() {\n      this.nationalSignificantNumber = this.getNationalDigits();\n      this.nationalSignificantNumberMatchesInput = true;\n      this.nationalPrefix = undefined;\n      this.carrierCode = undefined;\n      this.complexPrefixBeforeNationalSignificantNumber = undefined;\n    }\n  }, {\n    key: \"update\",\n    value: function update(properties) {\n      for (var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        this[key] = properties[key];\n      }\n    }\n  }, {\n    key: \"initCountryAndCallingCode\",\n    value: function initCountryAndCallingCode(country, callingCode) {\n      this.setCountry(country);\n      this.setCallingCode(callingCode);\n    }\n  }, {\n    key: \"setCountry\",\n    value: function setCountry(country) {\n      this.country = country;\n      this.onCountryChange(country);\n    }\n  }, {\n    key: \"setCallingCode\",\n    value: function setCallingCode(callingCode) {\n      this.callingCode = callingCode;\n      this.onCallingCodeChange(callingCode, this.country);\n    }\n  }, {\n    key: \"startInternationalNumber\",\n    value: function startInternationalNumber(country, callingCode) {\n      // Prepend the `+` to parsed input.\n      this.international = true; // If a default country was set then reset it\n      // because an explicitly international phone\n      // number is being entered.\n\n      this.initCountryAndCallingCode(country, callingCode);\n    }\n  }, {\n    key: \"appendDigits\",\n    value: function appendDigits(nextDigits) {\n      this.digits += nextDigits;\n    }\n  }, {\n    key: \"appendNationalSignificantNumberDigits\",\n    value: function appendNationalSignificantNumberDigits(nextDigits) {\n      this.nationalSignificantNumber += nextDigits;\n    }\n    /**\r\n     * Returns the part of `this.digits` that corresponds to the national number.\r\n     * Basically, all digits that have been input by the user, except for the\r\n     * international prefix and the country calling code part\r\n     * (if the number is an international one).\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getNationalDigits\",\n    value: function getNationalDigits() {\n      if (this.international) {\n        return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));\n      }\n\n      return this.digits;\n    }\n  }, {\n    key: \"getDigitsWithoutInternationalPrefix\",\n    value: function getDigitsWithoutInternationalPrefix() {\n      if (this.international) {\n        if (this.IDDPrefix) {\n          return this.digits.slice(this.IDDPrefix.length);\n        }\n      }\n\n      return this.digits;\n    }\n  }]);\n\n  return AsYouTypeState;\n}();\n\nexport { AsYouTypeState as default };\n//# sourceMappingURL=AsYouTypeState.js.map","function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\nexport var DIGIT_PLACEHOLDER = 'x'; // '\\u2008' (punctuation space)\n\nvar DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER); // Counts all occurences of a symbol in a string.\n// Unicode-unsafe (because using `.split()`).\n\nexport function countOccurences(symbol, string) {\n  var count = 0; // Using `.split('')` to iterate through a string here\n  // to avoid requiring `Symbol.iterator` polyfill.\n  // `.split('')` is generally not safe for Unicode,\n  // but in this particular case for counting brackets it is safe.\n  // for (const character of string)\n\n  for (var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;) {\n    var character = _step.value;\n\n    if (character === symbol) {\n      count++;\n    }\n  }\n\n  return count;\n} // Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\n\nexport function repeat(string, times) {\n  if (times < 1) {\n    return '';\n  }\n\n  var result = '';\n\n  while (times > 1) {\n    if (times & 1) {\n      result += string;\n    }\n\n    times >>= 1;\n    string += string;\n  }\n\n  return result + string;\n}\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\n  if (string[cutBeforeIndex] === ')') {\n    cutBeforeIndex++;\n  }\n\n  return stripNonPairedParens(string.slice(0, cutBeforeIndex));\n}\nexport function closeNonPairedParens(template, cut_before) {\n  var retained_template = template.slice(0, cut_before);\n  var opening_braces = countOccurences('(', retained_template);\n  var closing_braces = countOccurences(')', retained_template);\n  var dangling_braces = opening_braces - closing_braces;\n\n  while (dangling_braces > 0 && cut_before < template.length) {\n    if (template[cut_before] === ')') {\n      dangling_braces--;\n    }\n\n    cut_before++;\n  }\n\n  return template.slice(0, cut_before);\n}\nexport function stripNonPairedParens(string) {\n  var dangling_braces = [];\n  var i = 0;\n\n  while (i < string.length) {\n    if (string[i] === '(') {\n      dangling_braces.push(i);\n    } else if (string[i] === ')') {\n      dangling_braces.pop();\n    }\n\n    i++;\n  }\n\n  var start = 0;\n  var cleared_string = '';\n  dangling_braces.push(string.length);\n\n  for (var _i = 0, _dangling_braces = dangling_braces; _i < _dangling_braces.length; _i++) {\n    var index = _dangling_braces[_i];\n    cleared_string += string.slice(start, index);\n    start = index + 1;\n  }\n\n  return cleared_string;\n}\nexport function populateTemplateWithDigits(template, position, digits) {\n  // Using `.split('')` to iterate through a string here\n  // to avoid requiring `Symbol.iterator` polyfill.\n  // `.split('')` is generally not safe for Unicode,\n  // but in this particular case for `digits` it is safe.\n  // for (const digit of digits)\n  for (var _iterator2 = _createForOfIteratorHelperLoose(digits.split('')), _step2; !(_step2 = _iterator2()).done;) {\n    var digit = _step2.value;\n\n    // If there is room for more digits in current `template`,\n    // then set the next digit in the `template`,\n    // and return the formatted digits so far.\n    // If more digits are entered than the current format could handle.\n    if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\n      return;\n    }\n\n    position = template.search(DIGIT_PLACEHOLDER_MATCHER);\n    template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);\n  }\n\n  return [template, position];\n}\n//# sourceMappingURL=AsYouTypeFormatter.util.js.map","import checkNumberLength from './helpers/checkNumberLength.js';\nimport parseDigits from './helpers/parseDigits.js';\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js';\nexport default function formatCompleteNumber(state, format, _ref) {\n  var metadata = _ref.metadata,\n      shouldTryNationalPrefixFormattingRule = _ref.shouldTryNationalPrefixFormattingRule,\n      getSeparatorAfterNationalPrefix = _ref.getSeparatorAfterNationalPrefix;\n  var matcher = new RegExp(\"^(?:\".concat(format.pattern(), \")$\"));\n\n  if (matcher.test(state.nationalSignificantNumber)) {\n    return formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {\n      metadata: metadata,\n      shouldTryNationalPrefixFormattingRule: shouldTryNationalPrefixFormattingRule,\n      getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix\n    });\n  }\n}\nexport function canFormatCompleteNumber(nationalSignificantNumber, metadata) {\n  return checkNumberLength(nationalSignificantNumber, metadata) === 'IS_POSSIBLE';\n}\n\nfunction formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, _ref2) {\n  var metadata = _ref2.metadata,\n      shouldTryNationalPrefixFormattingRule = _ref2.shouldTryNationalPrefixFormattingRule,\n      getSeparatorAfterNationalPrefix = _ref2.getSeparatorAfterNationalPrefix;\n  // `format` has already been checked for `nationalPrefix` requirement.\n  var nationalSignificantNumber = state.nationalSignificantNumber,\n      international = state.international,\n      nationalPrefix = state.nationalPrefix,\n      carrierCode = state.carrierCode; // Format the number with using `national_prefix_formatting_rule`.\n  // If the resulting formatted number is a valid formatted number, then return it.\n  //\n  // Google's AsYouType formatter is different in a way that it doesn't try\n  // to format using the \"national prefix formatting rule\", and instead it\n  // simply prepends a national prefix followed by a \" \" character.\n  // This code does that too, but as a fallback.\n  // The reason is that \"national prefix formatting rule\" may use parentheses,\n  // which wouldn't be included has it used the simpler Google's way.\n  //\n\n  if (shouldTryNationalPrefixFormattingRule(format)) {\n    var formattedNumber = formatNationalNumber(state, format, {\n      useNationalPrefixFormattingRule: true,\n      getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,\n      metadata: metadata\n    });\n\n    if (formattedNumber) {\n      return formattedNumber;\n    }\n  } // Format the number without using `national_prefix_formatting_rule`.\n\n\n  return formatNationalNumber(state, format, {\n    useNationalPrefixFormattingRule: false,\n    getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,\n    metadata: metadata\n  });\n}\n\nfunction formatNationalNumber(state, format, _ref3) {\n  var metadata = _ref3.metadata,\n      useNationalPrefixFormattingRule = _ref3.useNationalPrefixFormattingRule,\n      getSeparatorAfterNationalPrefix = _ref3.getSeparatorAfterNationalPrefix;\n  var formattedNationalNumber = formatNationalNumberUsingFormat(state.nationalSignificantNumber, format, {\n    carrierCode: state.carrierCode,\n    useInternationalFormat: state.international,\n    withNationalPrefix: useNationalPrefixFormattingRule,\n    metadata: metadata\n  });\n\n  if (!useNationalPrefixFormattingRule) {\n    if (state.nationalPrefix) {\n      // If a national prefix was extracted, then just prepend it,\n      // followed by a \" \" character.\n      formattedNationalNumber = state.nationalPrefix + getSeparatorAfterNationalPrefix(format) + formattedNationalNumber;\n    } else if (state.complexPrefixBeforeNationalSignificantNumber) {\n      formattedNationalNumber = state.complexPrefixBeforeNationalSignificantNumber + ' ' + formattedNationalNumber;\n    }\n  }\n\n  if (isValidFormattedNationalNumber(formattedNationalNumber, state)) {\n    return formattedNationalNumber;\n  }\n} // Check that the formatted phone number contains exactly\n// the same digits that have been input by the user.\n// For example, when \"0111523456789\" is input for `AR` country,\n// the extracted `this.nationalSignificantNumber` is \"91123456789\",\n// which means that the national part of `this.digits` isn't simply equal to\n// `this.nationalPrefix` + `this.nationalSignificantNumber`.\n//\n// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`\n// being formatted via `metadata[country].national_prefix_transform_rule`.\n// For example, for `VI` country, it prepends `340` to the national number,\n// and if this check hasn't been implemented, then there would be a bug\n// when `340` \"area coude\" is \"duplicated\" during input for `VI` country:\n// https://github.com/catamphetamine/libphonenumber-js/issues/318\n//\n// So, all these \"gotchas\" are filtered out.\n//\n// In the original Google's code, the comments say:\n// \"Check that we didn't remove nor add any extra digits when we matched\n// this formatting pattern. This usually happens after we entered the last\n// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\n// formatted but AYTF should retain all the number entered and not change\n// in order to match a format (of same leading digits and length) display\n// in that way.\"\n// \"If it's the same (i.e entered number and format is same), then it's\n// safe to return this in formatted number as nothing is lost / added.\"\n// Otherwise, don't use this format.\n// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\n// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\n//\n\n\nfunction isValidFormattedNationalNumber(formattedNationalNumber, state) {\n  return parseDigits(formattedNationalNumber) === state.getNationalDigits();\n}\n//# sourceMappingURL=AsYouTypeFormatter.complete.js.map","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar PatternParser = /*#__PURE__*/function () {\n  function PatternParser() {\n    _classCallCheck(this, PatternParser);\n  }\n\n  _createClass(PatternParser, [{\n    key: \"parse\",\n    value: function parse(pattern) {\n      this.context = [{\n        or: true,\n        instructions: []\n      }];\n      this.parsePattern(pattern);\n\n      if (this.context.length !== 1) {\n        throw new Error('Non-finalized contexts left when pattern parse ended');\n      }\n\n      var _this$context$ = this.context[0],\n          branches = _this$context$.branches,\n          instructions = _this$context$.instructions;\n\n      if (branches) {\n        return {\n          op: '|',\n          args: branches.concat([expandSingleElementArray(instructions)])\n        };\n      }\n      /* istanbul ignore if */\n\n\n      if (instructions.length === 0) {\n        throw new Error('Pattern is required');\n      }\n\n      if (instructions.length === 1) {\n        return instructions[0];\n      }\n\n      return instructions;\n    }\n  }, {\n    key: \"startContext\",\n    value: function startContext(context) {\n      this.context.push(context);\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this.context.pop();\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context[this.context.length - 1];\n    }\n  }, {\n    key: \"parsePattern\",\n    value: function parsePattern(pattern) {\n      if (!pattern) {\n        throw new Error('Pattern is required');\n      }\n\n      var match = pattern.match(OPERATOR);\n\n      if (!match) {\n        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\n          throw new Error(\"Illegal characters found in a pattern: \".concat(pattern));\n        }\n\n        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));\n        return;\n      }\n\n      var operator = match[1];\n      var before = pattern.slice(0, match.index);\n      var rightPart = pattern.slice(match.index + operator.length);\n\n      switch (operator) {\n        case '(?:':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            or: true,\n            instructions: [],\n            branches: []\n          });\n          break;\n\n        case ')':\n          if (!this.getContext().or) {\n            throw new Error('\")\" operator must be preceded by \"(?:\" operator');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          if (this.getContext().instructions.length === 0) {\n            throw new Error('No instructions found after \"|\" operator in an \"or\" group');\n          }\n\n          var _this$getContext = this.getContext(),\n              branches = _this$getContext.branches;\n\n          branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '|',\n            args: branches\n          });\n          break;\n\n        case '|':\n          if (!this.getContext().or) {\n            throw new Error('\"|\" operator can only be used inside \"or\" groups');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          } // The top-level is an implicit \"or\" group, if required.\n\n\n          if (!this.getContext().branches) {\n            // `branches` are not defined only for the root implicit \"or\" operator.\n\n            /* istanbul ignore else */\n            if (this.context.length === 1) {\n              this.getContext().branches = [];\n            } else {\n              throw new Error('\"branches\" not found in an \"or\" group context');\n            }\n          }\n\n          this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.getContext().instructions = [];\n          break;\n\n        case '[':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            oneOfSet: true\n          });\n          break;\n\n        case ']':\n          if (!this.getContext().oneOfSet) {\n            throw new Error('\"]\" operator must be preceded by \"[\" operator');\n          }\n\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '[]',\n            args: parseOneOfSet(before)\n          });\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown operator: \".concat(operator));\n      }\n\n      if (rightPart) {\n        this.parsePattern(rightPart);\n      }\n    }\n  }]);\n\n  return PatternParser;\n}();\n\nexport { PatternParser as default };\n\nfunction parseOneOfSet(pattern) {\n  var values = [];\n  var i = 0;\n\n  while (i < pattern.length) {\n    if (pattern[i] === '-') {\n      if (i === 0 || i === pattern.length - 1) {\n        throw new Error(\"Couldn't parse a one-of set pattern: \".concat(pattern));\n      }\n\n      var prevValue = pattern[i - 1].charCodeAt(0) + 1;\n      var nextValue = pattern[i + 1].charCodeAt(0) - 1;\n      var value = prevValue;\n\n      while (value <= nextValue) {\n        values.push(String.fromCharCode(value));\n        value++;\n      }\n    } else {\n      values.push(pattern[i]);\n    }\n\n    i++;\n  }\n\n  return values;\n}\n\nvar ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/;\nvar OPERATOR = new RegExp( // any of:\n'(' + // or operator\n'\\\\|' + // or\n'|' + // or group start\n'\\\\(\\\\?\\\\:' + // or\n'|' + // or group end\n'\\\\)' + // or\n'|' + // one-of set start\n'\\\\[' + // or\n'|' + // one-of set end\n'\\\\]' + ')');\n\nfunction expandSingleElementArray(array) {\n  if (array.length === 1) {\n    return array[0];\n  }\n\n  return array;\n}\n//# sourceMappingURL=AsYouTypeFormatter.PatternParser.js.map","function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport PatternParser from './AsYouTypeFormatter.PatternParser.js';\n\nvar PatternMatcher = /*#__PURE__*/function () {\n  function PatternMatcher(pattern) {\n    _classCallCheck(this, PatternMatcher);\n\n    this.matchTree = new PatternParser().parse(pattern);\n  }\n\n  _createClass(PatternMatcher, [{\n    key: \"match\",\n    value: function match(string) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          allowOverflow = _ref.allowOverflow;\n\n      if (!string) {\n        throw new Error('String is required');\n      }\n\n      var result = _match(string.split(''), this.matchTree, true);\n\n      if (result && result.match) {\n        delete result.matchedChars;\n      }\n\n      if (result && result.overflow) {\n        if (!allowOverflow) {\n          return;\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return PatternMatcher;\n}();\n/**\r\n * Matches `characters` against a pattern compiled into a `tree`.\r\n * @param  {string[]} characters\r\n * @param  {Tree} tree  A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.\r\n * @param  {boolean} last  Whether it's the last (rightmost) subtree on its level of the match tree.\r\n * @return {object} See the `*.d.ts` file for the description of the result object.\r\n */\n\n\nexport { PatternMatcher as default };\n\nfunction _match(characters, tree, last) {\n  // If `tree` is a string, then `tree` is a single character.\n  // That's because when a pattern is parsed, multi-character-string parts\n  // of a pattern are compiled into arrays of single characters.\n  // I still wrote this piece of code for a \"general\" hypothetical case\n  // when `tree` could be a string of several characters, even though\n  // such case is not possible with the current implementation.\n  if (typeof tree === 'string') {\n    var characterString = characters.join('');\n\n    if (tree.indexOf(characterString) === 0) {\n      // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n\n      /* istanbul ignore else */\n      if (characters.length === tree.length) {\n        return {\n          match: true,\n          matchedChars: characters\n        };\n      } // `tree` is always a single character.\n      // If `tree.indexOf(characterString) === 0`\n      // then `characters.length === tree.length`.\n\n      /* istanbul ignore next */\n\n\n      return {\n        partialMatch: true // matchedChars: characters\n\n      };\n    }\n\n    if (characterString.indexOf(tree) === 0) {\n      if (last) {\n        // The `else` path is not possible because `tree` is always a single character.\n        // The `else` case for `characters.length > tree.length` would be\n        // `characters.length <= tree.length` which means `characters.length <= 1`.\n        // `characters` array can't be empty, so that means `characters === [tree]`,\n        // which would also mean `tree.indexOf(characterString) === 0` and that'd mean\n        // that the `if (tree.indexOf(characterString) === 0)` condition before this\n        // `if` condition would be entered, and returned from there, not reaching this code.\n\n        /* istanbul ignore else */\n        if (characters.length > tree.length) {\n          return {\n            overflow: true\n          };\n        }\n      }\n\n      return {\n        match: true,\n        matchedChars: characters.slice(0, tree.length)\n      };\n    }\n\n    return;\n  }\n\n  if (Array.isArray(tree)) {\n    var restCharacters = characters.slice();\n    var i = 0;\n\n    while (i < tree.length) {\n      var subtree = tree[i];\n\n      var result = _match(restCharacters, subtree, last && i === tree.length - 1);\n\n      if (!result) {\n        return;\n      } else if (result.overflow) {\n        return result;\n      } else if (result.match) {\n        // Continue with the next subtree with the rest of the characters.\n        restCharacters = restCharacters.slice(result.matchedChars.length);\n\n        if (restCharacters.length === 0) {\n          if (i === tree.length - 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          } else {\n            return {\n              partialMatch: true // matchedChars: characters\n\n            };\n          }\n        }\n      } else {\n        /* istanbul ignore else */\n        if (result.partialMatch) {\n          return {\n            partialMatch: true // matchedChars: characters\n\n          };\n        } else {\n          throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(result, null, 2)));\n        }\n      }\n\n      i++;\n    } // If `last` then overflow has already been checked\n    // by the last element of the `tree` array.\n\n    /* istanbul ignore if */\n\n\n    if (last) {\n      return {\n        overflow: true\n      };\n    }\n\n    return {\n      match: true,\n      matchedChars: characters.slice(0, characters.length - restCharacters.length)\n    };\n  }\n\n  switch (tree.op) {\n    case '|':\n      var partialMatch;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(tree.args), _step; !(_step = _iterator()).done;) {\n        var branch = _step.value;\n\n        var _result = _match(characters, branch, last);\n\n        if (_result) {\n          if (_result.overflow) {\n            return _result;\n          } else if (_result.match) {\n            return {\n              match: true,\n              matchedChars: _result.matchedChars\n            };\n          } else {\n            /* istanbul ignore else */\n            if (_result.partialMatch) {\n              partialMatch = true;\n            } else {\n              throw new Error(\"Unsupported match result:\\n\".concat(JSON.stringify(_result, null, 2)));\n            }\n          }\n        }\n      }\n\n      if (partialMatch) {\n        return {\n          partialMatch: true // matchedChars: ...\n\n        };\n      } // Not even a partial match.\n\n\n      return;\n\n    case '[]':\n      for (var _iterator2 = _createForOfIteratorHelperLoose(tree.args), _step2; !(_step2 = _iterator2()).done;) {\n        var _char = _step2.value;\n\n        if (characters[0] === _char) {\n          if (characters.length === 1) {\n            return {\n              match: true,\n              matchedChars: characters\n            };\n          }\n\n          if (last) {\n            return {\n              overflow: true\n            };\n          }\n\n          return {\n            match: true,\n            matchedChars: [_char]\n          };\n        }\n      } // No character matches.\n\n\n      return;\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(\"Unsupported instruction tree: \".concat(tree));\n  }\n}\n//# sourceMappingURL=AsYouTypeFormatter.PatternMatcher.js.map","function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { DIGIT_PLACEHOLDER, countOccurences, repeat, cutAndStripNonPairedParens, closeNonPairedParens, stripNonPairedParens, populateTemplateWithDigits } from './AsYouTypeFormatter.util.js';\nimport formatCompleteNumber, { canFormatCompleteNumber } from './AsYouTypeFormatter.complete.js';\nimport PatternMatcher from './AsYouTypeFormatter.PatternMatcher.js';\nimport parseDigits from './helpers/parseDigits.js';\nexport { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.util.js';\nimport { FIRST_GROUP_PATTERN } from './helpers/formatNationalNumberUsingFormat.js';\nimport { VALID_PUNCTUATION } from './constants.js';\nimport applyInternationalSeparatorStyle from './helpers/applyInternationalSeparatorStyle.js'; // Used in phone number format template creation.\n// Could be any digit, I guess.\n\nvar DUMMY_DIGIT = '9'; // I don't know why is it exactly `15`\n\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15; // Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\n\nvar LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH); // A set of characters that, if found in a national prefix formatting rules, are an indicator to\n// us that we should separate the national prefix from the number when formatting.\n\nvar NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/; // Deprecated: Google has removed some formatting pattern related code from their repo.\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\n// Because this library supports generating custom metadata\n// some users may still be using old metadata so the relevant\n// code seems to stay until some next major version update.\n\nvar SUPPORT_LEGACY_FORMATTING_PATTERNS = true; // A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\n\nvar CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\[([^\\[\\]])*\\]/g;\n}; // Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\n\n\nvar CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {\n  return /\\d(?=[^,}][^,}])/g;\n}; // A regular expression that is used to determine if a `format` is\n// suitable to be used in the \"as you type formatter\".\n// A `format` is suitable when the resulting formatted number has\n// the same digits as the user has entered.\n//\n// In the simplest case, that would mean that the format\n// doesn't add any additional digits when formatting a number.\n// Google says that it also shouldn't add \"star\" (`*`) characters,\n// like it does in some Israeli formats.\n// Such basic format would only contain \"valid punctuation\"\n// and \"captured group\" identifiers ($1, $2, etc).\n//\n// An example of a format that adds additional digits:\n//\n// Country: `AR` (Argentina).\n// Format:\n// {\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n//    \"leading_digits_patterns\": [\"91\"],\n//    \"national_prefix_formatting_rule\": \"0$1\",\n//    \"format\": \"$2 15-$3-$4\",\n//    \"international_format\": \"$1 $2 $3-$4\"\n// }\n//\n// In the format above, the `format` adds `15` to the digits when formatting a number.\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\n// has previously removed `15` from a national number, so re-adding `15` in `format`\n// doesn't actually result in any extra digits added to user's input.\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\n//\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\n// `libphonenumber` code.\n//\n\n\nvar NON_ALTERING_FORMAT_REG_EXP = new RegExp('[' + VALID_PUNCTUATION + ']*' + // Google developers say:\n// \"We require that the first matching group is present in the\n//  output pattern to ensure no data is lost while formatting.\"\n'\\\\$1' + '[' + VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)*' + '$'); // This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\n\nvar MIN_LEADING_DIGITS_LENGTH = 3;\n\nvar AsYouTypeFormatter = /*#__PURE__*/function () {\n  function AsYouTypeFormatter(_ref) {\n    var state = _ref.state,\n        metadata = _ref.metadata;\n\n    _classCallCheck(this, AsYouTypeFormatter);\n\n    this.metadata = metadata;\n    this.resetFormat();\n  }\n\n  _createClass(AsYouTypeFormatter, [{\n    key: \"resetFormat\",\n    value: function resetFormat() {\n      this.chosenFormat = undefined;\n      this.template = undefined;\n      this.nationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplate = undefined;\n      this.populatedNationalNumberTemplatePosition = -1;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan, state) {\n      this.resetFormat();\n\n      if (numberingPlan) {\n        this.isNANP = numberingPlan.callingCode() === '1';\n        this.matchingFormats = numberingPlan.formats();\n\n        if (state.nationalSignificantNumber) {\n          this.narrowDownMatchingFormats(state);\n        }\n      } else {\n        this.isNANP = undefined;\n        this.matchingFormats = [];\n      }\n    }\n    /**\r\n     * Formats an updated phone number.\r\n     * @param  {string} nextDigits  Additional phone number digits.\r\n     * @param  {object} state `AsYouType` state.\r\n     * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(nextDigits, state) {\n      var _this = this;\n\n      // See if the phone number digits can be formatted as a complete phone number.\n      // If not, use the results from `formatNationalNumberWithNextDigits()`,\n      // which formats based on the chosen formatting pattern.\n      //\n      // Attempting to format complete phone number first is how it's done\n      // in Google's `libphonenumber`, so this library just follows it.\n      // Google's `libphonenumber` code doesn't explain in detail why does it\n      // attempt to format digits as a complete phone number\n      // instead of just going with a previoulsy (or newly) chosen `format`:\n      //\n      // \"Checks to see if there is an exact pattern match for these digits.\n      //  If so, we should use this instead of any other formatting template\n      //  whose leadingDigitsPattern also matches the input.\"\n      //\n      if (canFormatCompleteNumber(state.nationalSignificantNumber, this.metadata)) {\n        for (var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;) {\n          var format = _step.value;\n          var formattedCompleteNumber = formatCompleteNumber(state, format, {\n            metadata: this.metadata,\n            shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format) {\n              return _this.shouldTryNationalPrefixFormattingRule(format, {\n                international: state.international,\n                nationalPrefix: state.nationalPrefix\n              });\n            },\n            getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format) {\n              return _this.getSeparatorAfterNationalPrefix(format);\n            }\n          });\n\n          if (formattedCompleteNumber) {\n            this.resetFormat();\n            this.chosenFormat = format;\n            this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, DIGIT_PLACEHOLDER), state);\n            this.populatedNationalNumberTemplate = formattedCompleteNumber; // With a new formatting template, the matched position\n            // using the old template needs to be reset.\n\n            this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER);\n            return formattedCompleteNumber;\n          }\n        }\n      } // Format the digits as a partial (incomplete) phone number\n      // using the previously chosen formatting pattern (or a newly chosen one).\n\n\n      return this.formatNationalNumberWithNextDigits(nextDigits, state);\n    } // Formats the next phone number digits.\n\n  }, {\n    key: \"formatNationalNumberWithNextDigits\",\n    value: function formatNationalNumberWithNextDigits(nextDigits, state) {\n      var previouslyChosenFormat = this.chosenFormat; // Choose a format from the list of matching ones.\n\n      var newlyChosenFormat = this.chooseFormat(state);\n\n      if (newlyChosenFormat) {\n        if (newlyChosenFormat === previouslyChosenFormat) {\n          // If it can format the next (current) digits\n          // using the previously chosen phone number format\n          // then return the updated formatted number.\n          return this.formatNextNationalNumberDigits(nextDigits);\n        } else {\n          // If a more appropriate phone number format\n          // has been chosen for these \"leading digits\",\n          // then re-format the national phone number part\n          // using the newly selected format.\n          return this.formatNextNationalNumberDigits(state.getNationalDigits());\n        }\n      }\n    }\n  }, {\n    key: \"narrowDownMatchingFormats\",\n    value: function narrowDownMatchingFormats(_ref2) {\n      var _this2 = this;\n\n      var nationalSignificantNumber = _ref2.nationalSignificantNumber,\n          nationalPrefix = _ref2.nationalPrefix,\n          international = _ref2.international;\n      var leadingDigits = nationalSignificantNumber; // \"leading digits\" pattern list starts with a\n      // \"leading digits\" pattern fitting a maximum of 3 leading digits.\n      // So, after a user inputs 3 digits of a national (significant) phone number\n      // this national (significant) number can already be formatted.\n      // The next \"leading digits\" pattern is for 4 leading digits max,\n      // and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\n      // This implementation is different from Google's\n      // in that it searches for a fitting format\n      // even if the user has entered less than\n      // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\n      // Because some leading digit patterns already match for a single first digit.\n\n      var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;\n\n      if (leadingDigitsPatternIndex < 0) {\n        leadingDigitsPatternIndex = 0;\n      }\n\n      this.matchingFormats = this.matchingFormats.filter(function (format) {\n        return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);\n      }); // If there was a phone number format chosen\n      // and it no longer holds given the new leading digits then reset it.\n      // The test for this `if` condition is marked as:\n      // \"Reset a chosen format when it no longer holds given the new leading digits\".\n      // To construct a valid test case for this one can find a country\n      // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\n      // and yielding another format for 4 `<leadingDigits>` (Australia in this case).\n\n      if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\n        this.resetFormat();\n      }\n    }\n  }, {\n    key: \"formatSuits\",\n    value: function formatSuits(format, international, nationalPrefix) {\n      // When a prefix before a national (significant) number is\n      // simply a national prefix, then it's parsed as `this.nationalPrefix`.\n      // In more complex cases, a prefix before national (significant) number\n      // could include a national prefix as well as some \"capturing groups\",\n      // and in that case there's no info whether a national prefix has been parsed.\n      // If national prefix is not used when formatting a phone number\n      // using this format, but a national prefix has been entered by the user,\n      // and was extracted, then discard such phone number format.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\n      if (nationalPrefix && !format.usesNationalPrefix() && // !format.domesticCarrierCodeFormattingRule() &&\n      !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\n        return false;\n      } // If national prefix is mandatory for this phone number format\n      // and there're no guarantees that a national prefix is present in user input\n      // then discard this phone number format as not suitable.\n      // In Google's \"AsYouType\" formatter code, the equivalent would be this part:\n      // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\n\n\n      if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"formatMatches\",\n    value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\n      var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length; // If this format is not restricted to a certain\n      // leading digits pattern then it fits.\n      // The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\n\n      if (leadingDigitsPatternsCount === 0) {\n        return true;\n      } // Start narrowing down the list of possible formats based on the leading digits.\n      // (only previously matched formats take part in the narrowing down process)\n      // `leading_digits_patterns` start with 3 digits min\n      // and then go up from there one digit at a time.\n\n\n      leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);\n      var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]; // Google imposes a requirement on the leading digits\n      // to be minimum 3 digits long in order to be eligible\n      // for checking those with a leading digits pattern.\n      //\n      // Since `leading_digits_patterns` start with 3 digits min,\n      // Google's original `libphonenumber` library only starts\n      // excluding any non-matching formats only when the\n      // national number entered so far is at least 3 digits long,\n      // otherwise format matching would give false negatives.\n      //\n      // For example, when the digits entered so far are `2`\n      // and the leading digits pattern is `21` \n      // it's quite obvious in this case that the format could be the one\n      // but due to the absence of further digits it would give false negative.\n      //\n      // Also, `leading_digits_patterns` doesn't always correspond to a single\n      // digits count. For example, `60|8` pattern would already match `8`\n      // but the `60` part would require having at least two leading digits,\n      // so the whole pattern would require inputting two digits first in order to\n      // decide on whether it matches the input, even when the input is \"80\".\n      //\n      // This library  `libphonenumber-js`  allows filtering by `leading_digits_patterns`\n      // even when there's only 1 or 2 digits of the national (significant) number.\n      // To do that, it uses a non-strict pattern matcher written specifically for that.\n      //\n\n      if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\n        // Before leading digits < 3 matching was implemented:\n        // return true\n        //\n        // After leading digits < 3 matching was implemented:\n        try {\n          return new PatternMatcher(leadingDigitsPattern).match(leadingDigits, {\n            allowOverflow: true\n          }) !== undefined;\n        } catch (error)\n        /* istanbul ignore next */\n        {\n          // There's a slight possibility that there could be some undiscovered bug\n          // in the pattern matcher code. Since the \"leading digits < 3 matching\"\n          // feature is not \"essential\" for operation, it can fall back to the old way\n          // in case of any issues rather than halting the application's execution.\n          console.error(error);\n          return true;\n        }\n      } // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\n      // available then use the usual regular expression matching.\n      //\n      // The whole pattern is wrapped in round brackets (`()`) because\n      // the pattern can use \"or\" operator (`|`) at the top level of the pattern.\n      //\n\n\n      return new RegExp(\"^(\".concat(leadingDigitsPattern, \")\")).test(leadingDigits);\n    }\n  }, {\n    key: \"getFormatFormat\",\n    value: function getFormatFormat(format, international) {\n      return international ? format.internationalFormat() : format.format();\n    }\n  }, {\n    key: \"chooseFormat\",\n    value: function chooseFormat(state) {\n      var _this3 = this;\n\n      var _loop = function _loop() {\n        var format = _step2.value;\n\n        // If this format is currently being used\n        // and is still suitable, then stick to it.\n        if (_this3.chosenFormat === format) {\n          return \"break\";\n        } // Sometimes, a formatting rule inserts additional digits in a phone number,\n        // and \"as you type\" formatter can't do that: it should only use the digits\n        // that the user has input.\n        //\n        // For example, in Argentina, there's a format for mobile phone numbers:\n        //\n        // {\n        //    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\n        //    \"leading_digits_patterns\": [\"91\"],\n        //    \"national_prefix_formatting_rule\": \"0$1\",\n        //    \"format\": \"$2 15-$3-$4\",\n        //    \"international_format\": \"$1 $2 $3-$4\"\n        // }\n        //\n        // In that format, `international_format` is used instead of `format`\n        // because `format` inserts `15` in the formatted number,\n        // and `AsYouType` formatter should only use the digits\n        // the user has actually input, without adding any extra digits.\n        // In this case, it wouldn't make a difference, because the `15`\n        // is first stripped when applying `national_prefix_for_parsing`\n        // and then re-added when using `format`, so in reality it doesn't\n        // add any new digits to the number, but to detect that, the code\n        // would have to be more complex: it would have to try formatting\n        // the digits using the format and then see if any digits have\n        // actually been added or removed, and then, every time a new digit\n        // is input, it should re-check whether the chosen format doesn't\n        // alter the digits.\n        //\n        // Google's code doesn't go that far, and so does this library:\n        // it simply requires that a `format` doesn't add any additonal\n        // digits to user's input.\n        //\n        // Also, people in general should move from inputting phone numbers\n        // in national format (possibly with national prefixes)\n        // and use international phone number format instead:\n        // it's a logical thing in the modern age of mobile phones,\n        // globalization and the internet.\n        //\n\n        /* istanbul ignore if */\n\n\n        if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {\n          return \"continue\";\n        }\n\n        if (!_this3.createTemplateForFormat(format, state)) {\n          // Remove the format if it can't generate a template.\n          _this3.matchingFormats = _this3.matchingFormats.filter(function (_) {\n            return _ !== format;\n          });\n          return \"continue\";\n        }\n\n        _this3.chosenFormat = format;\n        return \"break\";\n      };\n\n      // When there are multiple available formats, the formatter uses the first\n      // format where a formatting template could be created.\n      //\n      // For some weird reason, `istanbul` says \"else path not taken\"\n      // for the `for of` line below. Supposedly that means that\n      // the loop doesn't ever go over the last element in the list.\n      // That's true because there always is `this.chosenFormat`\n      // when `this.matchingFormats` is non-empty.\n      // And, for some weird reason, it doesn't think that the case\n      // with empty `this.matchingFormats` qualifies for a valid \"else\" path.\n      // So simply muting this `istanbul` warning.\n      // It doesn't skip the contents of the `for of` loop,\n      // it just skips the `for of` line.\n      //\n\n      /* istanbul ignore next */\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done;) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n        if (_ret === \"continue\") continue;\n      }\n\n      if (!this.chosenFormat) {\n        // No format matches the national (significant) phone number.\n        this.resetFormat();\n      }\n\n      return this.chosenFormat;\n    }\n  }, {\n    key: \"createTemplateForFormat\",\n    value: function createTemplateForFormat(format, state) {\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\n      // (20|3)\\d{4}. In those cases we quickly return.\n      // (Though there's no such format in current metadata)\n\n      /* istanbul ignore if */\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\n        return;\n      } // Get formatting template for this phone number format\n\n\n      var template = this.getTemplateForFormat(format, state); // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (template) {\n        this.setNationalNumberTemplate(template, state);\n        return true;\n      }\n    }\n  }, {\n    key: \"getSeparatorAfterNationalPrefix\",\n    value: function getSeparatorAfterNationalPrefix(format) {\n      // `US` metadata doesn't have a `national_prefix_formatting_rule`,\n      // so the `if` condition below doesn't apply to `US`,\n      // but in reality there shoudl be a separator\n      // between a national prefix and a national (significant) number.\n      // So `US` national prefix separator is a \"special\" \"hardcoded\" case.\n      if (this.isNANP) {\n        return ' ';\n      } // If a `format` has a `national_prefix_formatting_rule`\n      // and that rule has a separator after a national prefix,\n      // then it means that there should be a separator\n      // between a national prefix and a national (significant) number.\n\n\n      if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\n        return ' ';\n      } // At this point, there seems to be no clear evidence that\n      // there should be a separator between a national prefix\n      // and a national (significant) number. So don't insert one.\n\n\n      return '';\n    }\n  }, {\n    key: \"getInternationalPrefixBeforeCountryCallingCode\",\n    value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {\n      var IDDPrefix = _ref3.IDDPrefix,\n          missingPlus = _ref3.missingPlus;\n\n      if (IDDPrefix) {\n        return options && options.spacing === false ? IDDPrefix : IDDPrefix + ' ';\n      }\n\n      if (missingPlus) {\n        return '';\n      }\n\n      return '+';\n    }\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate(state) {\n      if (!this.template) {\n        return;\n      } // `this.template` holds the template for a \"complete\" phone number.\n      // The currently entered phone number is most likely not \"complete\",\n      // so trim all non-populated digits.\n\n\n      var index = -1;\n      var i = 0;\n      var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {\n        spacing: false\n      }) : '';\n\n      while (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\n        index = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1);\n        i++;\n      }\n\n      return cutAndStripNonPairedParens(this.template, index + 1);\n    }\n  }, {\n    key: \"setNationalNumberTemplate\",\n    value: function setNationalNumberTemplate(template, state) {\n      this.nationalNumberTemplate = template;\n      this.populatedNationalNumberTemplate = template; // With a new formatting template, the matched position\n      // using the old template needs to be reset.\n\n      this.populatedNationalNumberTemplatePosition = -1; // For convenience, the public `.template` property\n      // contains the whole international number\n      // if the phone number being input is international:\n      // 'x' for the '+' sign, 'x'es for the country phone code,\n      // a spacebar and then the template for the formatted national number.\n\n      if (state.international) {\n        this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) + repeat(DIGIT_PLACEHOLDER, state.callingCode.length) + ' ' + template;\n      } else {\n        this.template = template;\n      }\n    }\n    /**\r\n     * Generates formatting template for a national phone number,\r\n     * optionally containing a national prefix, for a format.\r\n     * @param  {Format} format\r\n     * @param  {string} nationalPrefix\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getTemplateForFormat\",\n    value: function getTemplateForFormat(format, _ref4) {\n      var nationalSignificantNumber = _ref4.nationalSignificantNumber,\n          international = _ref4.international,\n          nationalPrefix = _ref4.nationalPrefix,\n          complexPrefixBeforeNationalSignificantNumber = _ref4.complexPrefixBeforeNationalSignificantNumber;\n      var pattern = format.pattern();\n      /* istanbul ignore else */\n\n      if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\n        pattern = pattern // Replace anything in the form of [..] with \\d\n        .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d') // Replace any standalone digit (not the one in `{}`) with \\d\n        .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d');\n      } // Generate a dummy national number (consisting of `9`s)\n      // that fits this format's `pattern`.\n      //\n      // This match will always succeed,\n      // because the \"longest dummy phone number\"\n      // has enough length to accomodate any possible\n      // national phone number format pattern.\n      //\n\n\n      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]; // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (nationalSignificantNumber.length > digits.length) {\n        return;\n      } // Get a formatting template which can be used to efficiently format\n      // a partial number where digits are added one by one.\n      // Below `strictPattern` is used for the\n      // regular expression (with `^` and `$`).\n      // This wasn't originally in Google's `libphonenumber`\n      // and I guess they don't really need it\n      // because they're not using \"templates\" to format phone numbers\n      // but I added `strictPattern` after encountering\n      // South Korean phone number formatting bug.\n      //\n      // Non-strict regular expression bug demonstration:\n      //\n      // this.nationalSignificantNumber : `111111111` (9 digits)\n      //\n      // pattern : (\\d{2})(\\d{3,4})(\\d{4})\n      // format : `$1 $2 $3`\n      // digits : `9999999999` (10 digits)\n      //\n      // '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n      //\n      // template : xx xxxx xxxx\n      //\n      // But the correct template in this case is `xx xxx xxxx`.\n      // The template was generated incorrectly because of the\n      // `{3,4}` variability in the `pattern`.\n      //\n      // The fix is, if `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then `this.nationalSignificantNumber`\n      // is used instead of `digits`.\n\n\n      var strictPattern = new RegExp('^' + pattern + '$');\n      var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT); // If `this.nationalSignificantNumber` has already sufficient length\n      // to satisfy the `pattern` completely then use it\n      // instead of `digits`.\n\n      if (strictPattern.test(nationalNumberDummyDigits)) {\n        digits = nationalNumberDummyDigits;\n      }\n\n      var numberFormat = this.getFormatFormat(format, international);\n      var nationalPrefixIncludedInTemplate; // If a user did input a national prefix (and that's guaranteed),\n      // and if a `format` does have a national prefix formatting rule,\n      // then see if that national prefix formatting rule\n      // prepends exactly the same national prefix the user has input.\n      // If that's the case, then use the `format` with the national prefix formatting rule.\n      // Otherwise, use  the `format` without the national prefix formatting rule,\n      // and prepend a national prefix manually to it.\n\n      if (this.shouldTryNationalPrefixFormattingRule(format, {\n        international: international,\n        nationalPrefix: nationalPrefix\n      })) {\n        var numberFormatWithNationalPrefix = numberFormat.replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()); // If `national_prefix_formatting_rule` of a `format` simply prepends\n        // national prefix at the start of a national (significant) number,\n        // then such formatting can be used with `AsYouType` formatter.\n        // There seems to be no `else` case: everywhere in metadata,\n        // national prefix formatting rule is national prefix + $1,\n        // or `($1)`, in which case such format isn't even considered\n        // when the user has input a national prefix.\n\n        /* istanbul ignore else */\n\n        if (parseDigits(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + parseDigits('$1')) {\n          numberFormat = numberFormatWithNationalPrefix;\n          nationalPrefixIncludedInTemplate = true; // Replace all digits of the national prefix in the formatting template\n          // with `DIGIT_PLACEHOLDER`s.\n\n          if (nationalPrefix) {\n            var i = nationalPrefix.length;\n\n            while (i > 0) {\n              numberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER);\n              i--;\n            }\n          }\n        }\n      } // Generate formatting template for this phone number format.\n\n\n      var template = digits // Format the dummy phone number according to the format.\n      .replace(new RegExp(pattern), numberFormat) // Replace each dummy digit with a DIGIT_PLACEHOLDER.\n      .replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER); // If a prefix of a national (significant) number is not as simple\n      // as just a basic national prefix, then just prepend such prefix\n      // before the national (significant) number, optionally spacing\n      // the two with a whitespace.\n\n      if (!nationalPrefixIncludedInTemplate) {\n        if (complexPrefixBeforeNationalSignificantNumber) {\n          // Prepend the prefix to the template manually.\n          template = repeat(DIGIT_PLACEHOLDER, complexPrefixBeforeNationalSignificantNumber.length) + ' ' + template;\n        } else if (nationalPrefix) {\n          // Prepend national prefix to the template manually.\n          template = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;\n        }\n      }\n\n      if (international) {\n        template = applyInternationalSeparatorStyle(template);\n      }\n\n      return template;\n    }\n  }, {\n    key: \"formatNextNationalNumberDigits\",\n    value: function formatNextNationalNumberDigits(digits) {\n      var result = populateTemplateWithDigits(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);\n\n      if (!result) {\n        // Reset the format.\n        this.resetFormat();\n        return;\n      }\n\n      this.populatedNationalNumberTemplate = result[0];\n      this.populatedNationalNumberTemplatePosition = result[1]; // Return the formatted phone number so far.\n\n      return cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1); // The old way which was good for `input-format` but is not so good\n      // for `react-phone-number-input`'s default input (`InputBasic`).\n      // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\n      // \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\n    }\n  }, {\n    key: \"shouldTryNationalPrefixFormattingRule\",\n    value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {\n      var international = _ref5.international,\n          nationalPrefix = _ref5.nationalPrefix;\n\n      if (format.nationalPrefixFormattingRule()) {\n        // In some countries, `national_prefix_formatting_rule` is `($1)`,\n        // so it applies even if the user hasn't input a national prefix.\n        // `format.usesNationalPrefix()` detects such cases.\n        var usesNationalPrefix = format.usesNationalPrefix();\n\n        if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {\n          return true;\n        }\n      }\n    }\n  }]);\n\n  return AsYouTypeFormatter;\n}();\n\nexport { AsYouTypeFormatter as default };\n//# sourceMappingURL=AsYouTypeFormatter.js.map","function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport _extractCountryCallingCode from './helpers/extractCountryCallingCode.js';\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js';\nimport extractNationalNumberFromPossiblyIncompleteNumber from './helpers/extractNationalNumberFromPossiblyIncompleteNumber.js';\nimport stripIddPrefix from './helpers/stripIddPrefix.js';\nimport parseDigits from './helpers/parseDigits.js';\nimport { VALID_DIGITS, VALID_PUNCTUATION, PLUS_CHARS } from './constants.js';\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = '[' + VALID_PUNCTUATION + VALID_DIGITS + ']+';\nvar VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i');\nvar VALID_FORMATTED_PHONE_NUMBER_PART = '(?:' + '[' + PLUS_CHARS + ']' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*' + '|' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']+' + ')';\nvar AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp('[^' + VALID_PUNCTUATION + VALID_DIGITS + ']+' + '.*' + '$'); // Tests whether `national_prefix_for_parsing` could match\n// different national prefixes.\n// Matches anything that's not a digit or a square bracket.\n\nvar COMPLEX_NATIONAL_PREFIX = /[^\\d\\[\\]]/;\n\nvar AsYouTypeParser = /*#__PURE__*/function () {\n  function AsYouTypeParser(_ref) {\n    var defaultCountry = _ref.defaultCountry,\n        defaultCallingCode = _ref.defaultCallingCode,\n        metadata = _ref.metadata,\n        onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;\n\n    _classCallCheck(this, AsYouTypeParser);\n\n    this.defaultCountry = defaultCountry;\n    this.defaultCallingCode = defaultCallingCode;\n    this.metadata = metadata;\n    this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;\n  }\n\n  _createClass(AsYouTypeParser, [{\n    key: \"input\",\n    value: function input(text, state) {\n      var _extractFormattedDigi = extractFormattedDigitsAndPlus(text),\n          _extractFormattedDigi2 = _slicedToArray(_extractFormattedDigi, 2),\n          formattedDigits = _extractFormattedDigi2[0],\n          hasPlus = _extractFormattedDigi2[1];\n\n      var digits = parseDigits(formattedDigits); // Checks for a special case: just a leading `+` has been entered.\n\n      var justLeadingPlus;\n\n      if (hasPlus) {\n        if (!state.digits) {\n          state.startInternationalNumber();\n\n          if (!digits) {\n            justLeadingPlus = true;\n          }\n        }\n      }\n\n      if (digits) {\n        this.inputDigits(digits, state);\n      }\n\n      return {\n        digits: digits,\n        justLeadingPlus: justLeadingPlus\n      };\n    }\n    /**\r\n     * Inputs \"next\" phone number digits.\r\n     * @param  {string} digits\r\n     * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n     */\n\n  }, {\n    key: \"inputDigits\",\n    value: function inputDigits(nextDigits, state) {\n      var digits = state.digits;\n      var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3; // Append phone number digits.\n\n      state.appendDigits(nextDigits); // Attempt to extract IDD prefix:\n      // Some users input their phone number in international format,\n      // but in an \"out-of-country\" dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers as soon as there're at least 3 digits.\n      // Google's library attempts to extract IDD prefix at 3 digits,\n      // so this library just copies that behavior.\n      // I guess that's because the most commot IDD prefixes are\n      // `00` (Europe) and `011` (US).\n      // There exist really long IDD prefixes too:\n      // for example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      // An IDD prefix is extracted here, and then every time when\n      // there's a new digit and the number couldn't be formatted.\n\n      if (hasReceivedThreeLeadingDigits) {\n        this.extractIddPrefix(state);\n      }\n\n      if (this.isWaitingForCountryCallingCode(state)) {\n        if (!this.extractCountryCallingCode(state)) {\n          return;\n        }\n      } else {\n        state.appendNationalSignificantNumberDigits(nextDigits);\n      } // If a phone number is being input in international format,\n      // then it's not valid for it to have a national prefix.\n      // Still, some people incorrectly input such numbers with a national prefix.\n      // In such cases, only attempt to strip a national prefix if the number becomes too long.\n      // (but that is done later, not here)\n\n\n      if (!state.international) {\n        if (!this.hasExtractedNationalSignificantNumber) {\n          this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n            return state.update(stateUpdate);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"isWaitingForCountryCallingCode\",\n    value: function isWaitingForCountryCallingCode(_ref2) {\n      var international = _ref2.international,\n          callingCode = _ref2.callingCode;\n      return international && !callingCode;\n    } // Extracts a country calling code from a number\n    // being entered in internatonal format.\n\n  }, {\n    key: \"extractCountryCallingCode\",\n    value: function extractCountryCallingCode(state) {\n      var _extractCountryCallin = _extractCountryCallingCode('+' + state.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n          countryCallingCode = _extractCountryCallin.countryCallingCode,\n          number = _extractCountryCallin.number;\n\n      if (countryCallingCode) {\n        state.setCallingCode(countryCallingCode);\n        state.update({\n          nationalSignificantNumber: number\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(numberingPlan) {\n      if (numberingPlan) {\n        this.hasSelectedNumberingPlan = true;\n\n        var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();\n\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);\n      } else {\n        this.hasSelectedNumberingPlan = undefined;\n        this.couldPossiblyExtractAnotherNationalSignificantNumber = undefined;\n      }\n    }\n    /**\r\n     * Extracts a national (significant) number from user input.\r\n     * Google's library is different in that it only applies `national_prefix_for_parsing`\r\n     * and doesn't apply `national_prefix_transform_rule` after that.\r\n     * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539\r\n     * @return {boolean} [extracted]\r\n     */\n\n  }, {\n    key: \"extractNationalSignificantNumber\",\n    value: function extractNationalSignificantNumber(nationalDigits, setState) {\n      if (!this.hasSelectedNumberingPlan) {\n        return;\n      }\n\n      var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata),\n          nationalPrefix = _extractNationalNumbe.nationalPrefix,\n          nationalNumber = _extractNationalNumbe.nationalNumber,\n          carrierCode = _extractNationalNumbe.carrierCode;\n\n      if (nationalNumber === nationalDigits) {\n        return;\n      }\n\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n    /**\r\n     * In Google's code this function is called \"attempt to extract longer NDD\".\r\n     * \"Some national prefixes are a substring of others\", they say.\r\n     * @return {boolean} [result]  Returns `true` if extracting a national prefix produced different results from what they were.\r\n     */\n\n  }, {\n    key: \"extractAnotherNationalSignificantNumber\",\n    value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {\n      if (!this.hasExtractedNationalSignificantNumber) {\n        return this.extractNationalSignificantNumber(nationalDigits, setState);\n      }\n\n      if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {\n        return;\n      }\n\n      var _extractNationalNumbe2 = extractNationalNumberFromPossiblyIncompleteNumber(nationalDigits, this.metadata),\n          nationalPrefix = _extractNationalNumbe2.nationalPrefix,\n          nationalNumber = _extractNationalNumbe2.nationalNumber,\n          carrierCode = _extractNationalNumbe2.carrierCode; // If a national prefix has been extracted previously,\n      // then it's always extracted as additional digits are added.\n      // That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`\n      // doesn't do anything different from what it currently does.\n      // So, just in case, here's this check, though it doesn't occur.\n\n      /* istanbul ignore if */\n\n\n      if (nationalNumber === prevNationalSignificantNumber) {\n        return;\n      }\n\n      this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);\n      return true;\n    }\n  }, {\n    key: \"onExtractedNationalNumber\",\n    value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {\n      var complexPrefixBeforeNationalSignificantNumber;\n      var nationalSignificantNumberMatchesInput; // This check also works with empty `this.nationalSignificantNumber`.\n\n      var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber); // If the extracted national (significant) number is the\n      // last substring of the `digits`, then it means that it hasn't been altered:\n      // no digits have been removed from the national (significant) number\n      // while applying `national_prefix_transform_rule`.\n      // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\n\n      if (nationalSignificantNumberIndex >= 0 && nationalSignificantNumberIndex === nationalDigits.length - nationalSignificantNumber.length) {\n        nationalSignificantNumberMatchesInput = true; // If a prefix of a national (significant) number is not as simple\n        // as just a basic national prefix, then such prefix is stored in\n        // `this.complexPrefixBeforeNationalSignificantNumber` property and will be\n        // prepended \"as is\" to the national (significant) number to produce\n        // a formatted result.\n\n        var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex); // `prefixBeforeNationalNumber` is always non-empty,\n        // because `onExtractedNationalNumber()` isn't called\n        // when a national (significant) number hasn't been actually \"extracted\":\n        // when a national (significant) number is equal to the national part of `digits`,\n        // then `onExtractedNationalNumber()` doesn't get called.\n\n        if (prefixBeforeNationalNumber !== nationalPrefix) {\n          complexPrefixBeforeNationalSignificantNumber = prefixBeforeNationalNumber;\n        }\n      }\n\n      setState({\n        nationalPrefix: nationalPrefix,\n        carrierCode: carrierCode,\n        nationalSignificantNumber: nationalSignificantNumber,\n        nationalSignificantNumberMatchesInput: nationalSignificantNumberMatchesInput,\n        complexPrefixBeforeNationalSignificantNumber: complexPrefixBeforeNationalSignificantNumber\n      }); // `onExtractedNationalNumber()` is only called when\n      // the national (significant) number actually did change.\n\n      this.hasExtractedNationalSignificantNumber = true;\n      this.onNationalSignificantNumberChange();\n    }\n  }, {\n    key: \"reExtractNationalSignificantNumber\",\n    value: function reExtractNationalSignificantNumber(state) {\n      // Attempt to extract a national prefix.\n      //\n      // Some people incorrectly input national prefix\n      // in an international phone number.\n      // For example, some people write British phone numbers as `+44(0)...`.\n      //\n      // Also, in some rare cases, it is valid for a national prefix\n      // to be a part of an international phone number.\n      // For example, mobile phone numbers in Mexico are supposed to be\n      // dialled internationally using a `1` national prefix,\n      // so the national prefix will be part of an international number.\n      //\n      // Quote from:\n      // https://www.mexperience.com/dialing-cell-phones-in-mexico/\n      //\n      // \"Dialing a Mexican cell phone from abroad\n      // When you are calling a cell phone number in Mexico from outside Mexico,\n      // its necessary to dial an additional 1 after Mexicos country code\n      // (which is 52) and before the area code.\n      // You also ignore the 045, and simply dial the area code and the\n      // cell phones number.\n      //\n      // If you dont add the 1, youll receive a recorded announcement\n      // asking you to redial using it.\n      //\n      // For example, if you are calling from the USA to a cell phone\n      // in Mexico City, you would dial +52  1  55  1234 5678.\n      // (Note that this is different to calling a land line in Mexico City\n      // from abroad, where the number dialed would be +52  55  1234 5678)\".\n      //\n      // Google's demo output:\n      // https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX\n      //\n      if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function (stateUpdate) {\n        return state.update(stateUpdate);\n      })) {\n        return true;\n      } // If no format matches the phone number, then it could be\n      // \"a really long IDD\" (quote from a comment in Google's library).\n      // An IDD prefix is first extracted when the user has entered at least 3 digits,\n      // and then here  every time when there's a new digit and the number\n      // couldn't be formatted.\n      // For example, in Australia the default IDD prefix is `0011`,\n      // and it could even be as long as `14880011`.\n      //\n      // Could also check `!hasReceivedThreeLeadingDigits` here\n      // to filter out the case when this check duplicates the one\n      // already performed when there're 3 leading digits,\n      // but it's not a big deal, and in most cases there\n      // will be a suitable `format` when there're 3 leading digits.\n      //\n\n\n      if (this.extractIddPrefix(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      } // Google's AsYouType formatter supports sort of an \"autocorrection\" feature\n      // when it \"autocorrects\" numbers that have been input for a country\n      // with that country's calling code.\n      // Such \"autocorrection\" feature looks weird, but different people have been requesting it:\n      // https://github.com/catamphetamine/libphonenumber-js/issues/376\n      // https://github.com/catamphetamine/libphonenumber-js/issues/375\n      // https://github.com/catamphetamine/libphonenumber-js/issues/316\n\n\n      if (this.fixMissingPlus(state)) {\n        this.extractCallingCodeAndNationalSignificantNumber(state);\n        return true;\n      }\n    }\n  }, {\n    key: \"extractIddPrefix\",\n    value: function extractIddPrefix(state) {\n      // An IDD prefix can't be present in a number written with a `+`.\n      // Also, don't re-extract an IDD prefix if has already been extracted.\n      var international = state.international,\n          IDDPrefix = state.IDDPrefix,\n          digits = state.digits,\n          nationalSignificantNumber = state.nationalSignificantNumber;\n\n      if (international || IDDPrefix) {\n        return;\n      } // Some users input their phone number in \"out-of-country\"\n      // dialing format instead of using the leading `+`.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/185\n      // Detect such numbers.\n\n\n      var numberWithoutIDD = stripIddPrefix(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);\n\n      if (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {\n        // If an IDD prefix was stripped then convert the IDD-prefixed number\n        // to international number for subsequent parsing.\n        state.update({\n          IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)\n        });\n        this.startInternationalNumber(state, {\n          country: undefined,\n          callingCode: undefined\n        });\n        return true;\n      }\n    }\n  }, {\n    key: \"fixMissingPlus\",\n    value: function fixMissingPlus(state) {\n      if (!state.international) {\n        var _extractCountryCallin2 = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(state.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),\n            newCallingCode = _extractCountryCallin2.countryCallingCode,\n            number = _extractCountryCallin2.number;\n\n        if (newCallingCode) {\n          state.update({\n            missingPlus: true\n          });\n          this.startInternationalNumber(state, {\n            country: state.country,\n            callingCode: newCallingCode\n          });\n          return true;\n        }\n      }\n    }\n  }, {\n    key: \"startInternationalNumber\",\n    value: function startInternationalNumber(state, _ref3) {\n      var country = _ref3.country,\n          callingCode = _ref3.callingCode;\n      state.startInternationalNumber(country, callingCode); // If a national (significant) number has been extracted before, reset it.\n\n      if (state.nationalSignificantNumber) {\n        state.resetNationalSignificantNumber();\n        this.onNationalSignificantNumberChange();\n        this.hasExtractedNationalSignificantNumber = undefined;\n      }\n    }\n  }, {\n    key: \"extractCallingCodeAndNationalSignificantNumber\",\n    value: function extractCallingCodeAndNationalSignificantNumber(state) {\n      if (this.extractCountryCallingCode(state)) {\n        // `this.extractCallingCode()` is currently called when the number\n        // couldn't be formatted during the standard procedure.\n        // Normally, the national prefix would be re-extracted\n        // for an international number if such number couldn't be formatted,\n        // but since it's already not able to be formatted,\n        // there won't be yet another retry, so also extract national prefix here.\n        this.extractNationalSignificantNumber(state.getNationalDigits(), function (stateUpdate) {\n          return state.update(stateUpdate);\n        });\n      }\n    }\n  }]);\n\n  return AsYouTypeParser;\n}();\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\n\n\nexport { AsYouTypeParser as default };\n\nfunction extractFormattedPhoneNumber(text) {\n  // Attempt to extract a possible number from the string passed in.\n  var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);\n\n  if (startsAt < 0) {\n    return;\n  } // Trim everything to the left of the phone number.\n\n\n  text = text.slice(startsAt); // Trim the `+`.\n\n  var hasPlus;\n\n  if (text[0] === '+') {\n    hasPlus = true;\n    text = text.slice('+'.length);\n  } // Trim everything to the right of the phone number.\n\n\n  text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, ''); // Re-add the previously trimmed `+`.\n\n  if (hasPlus) {\n    text = '+' + text;\n  }\n\n  return text;\n}\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\n\n\nfunction _extractFormattedDigitsAndPlus(text) {\n  // Extract a formatted phone number part from text.\n  var extractedNumber = extractFormattedPhoneNumber(text) || ''; // Trim a `+`.\n\n  if (extractedNumber[0] === '+') {\n    return [extractedNumber.slice('+'.length), true];\n  }\n\n  return [extractedNumber];\n}\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\n\n\nexport function extractFormattedDigitsAndPlus(text) {\n  var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text),\n      _extractFormattedDigi4 = _slicedToArray(_extractFormattedDigi3, 2),\n      formattedDigits = _extractFormattedDigi4[0],\n      hasPlus = _extractFormattedDigi4[1]; // If the extracted phone number part\n  // can possibly be a part of some valid phone number\n  // then parse phone number characters from a formatted phone number.\n\n\n  if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {\n    formattedDigits = '';\n  }\n\n  return [formattedDigits, hasPlus];\n}\n//# sourceMappingURL=AsYouTypeParser.js.map","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport Metadata from './metadata.js';\nimport PhoneNumber from './PhoneNumber.js';\nimport AsYouTypeState from './AsYouTypeState.js';\nimport AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.js';\nimport AsYouTypeParser, { extractFormattedDigitsAndPlus } from './AsYouTypeParser.js';\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js';\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;\n\nvar AsYouType = /*#__PURE__*/function () {\n  /**\r\n   * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n   * @param {Object} metadata\r\n   */\n  function AsYouType(optionsOrDefaultCountry, metadata) {\n    _classCallCheck(this, AsYouType);\n\n    this.metadata = new Metadata(metadata);\n\n    var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry),\n        _this$getCountryAndCa2 = _slicedToArray(_this$getCountryAndCa, 2),\n        defaultCountry = _this$getCountryAndCa2[0],\n        defaultCallingCode = _this$getCountryAndCa2[1];\n\n    this.defaultCountry = defaultCountry;\n    this.defaultCallingCode = defaultCallingCode;\n    this.reset();\n  }\n\n  _createClass(AsYouType, [{\n    key: \"getCountryAndCallingCode\",\n    value: function getCountryAndCallingCode(optionsOrDefaultCountry) {\n      // Set `defaultCountry` and `defaultCallingCode` options.\n      var defaultCountry;\n      var defaultCallingCode; // Turns out `null` also has type \"object\". Weird.\n\n      if (optionsOrDefaultCountry) {\n        if (_typeof(optionsOrDefaultCountry) === 'object') {\n          defaultCountry = optionsOrDefaultCountry.defaultCountry;\n          defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;\n        } else {\n          defaultCountry = optionsOrDefaultCountry;\n        }\n      }\n\n      if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {\n        defaultCountry = undefined;\n      }\n\n      if (defaultCallingCode) {\n        /* istanbul ignore if */\n        if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n          if (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n            defaultCountry = '001';\n          }\n        }\n      }\n\n      return [defaultCountry, defaultCallingCode];\n    }\n    /**\r\n     * Inputs \"next\" phone number characters.\r\n     * @param  {string} text\r\n     * @return {string} Formatted phone number characters that have been input so far.\r\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(text) {\n      var _this$parser$input = this.parser.input(text, this.state),\n          digits = _this$parser$input.digits,\n          justLeadingPlus = _this$parser$input.justLeadingPlus;\n\n      if (justLeadingPlus) {\n        this.formattedOutput = '+';\n      } else if (digits) {\n        this.determineTheCountryIfNeeded(); // Match the available formats by the currently available leading digits.\n\n        if (this.state.nationalSignificantNumber) {\n          this.formatter.narrowDownMatchingFormats(this.state);\n        }\n\n        var formattedNationalNumber;\n\n        if (this.metadata.hasSelectedNumberingPlan()) {\n          formattedNationalNumber = this.formatter.format(digits, this.state);\n        }\n\n        if (formattedNationalNumber === undefined) {\n          // See if another national (significant) number could be re-extracted.\n          if (this.parser.reExtractNationalSignificantNumber(this.state)) {\n            this.determineTheCountryIfNeeded(); // If it could, then re-try formatting the new national (significant) number.\n\n            var nationalDigits = this.state.getNationalDigits();\n\n            if (nationalDigits) {\n              formattedNationalNumber = this.formatter.format(nationalDigits, this.state);\n            }\n          }\n        }\n\n        this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();\n      }\n\n      return this.formattedOutput;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var _this = this;\n\n      this.state = new AsYouTypeState({\n        onCountryChange: function onCountryChange(country) {\n          // Before version `1.6.0`, the official `AsYouType` formatter API\n          // included the `.country` property of an `AsYouType` instance.\n          // Since that property (along with the others) have been moved to\n          // `this.state`, `this.country` property is emulated for compatibility\n          // with the old versions.\n          _this.country = country;\n        },\n        onCallingCodeChange: function onCallingCodeChange(callingCode, country) {\n          _this.metadata.selectNumberingPlan(country, callingCode);\n\n          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);\n\n          _this.parser.reset(_this.metadata.numberingPlan);\n        }\n      });\n      this.formatter = new AsYouTypeFormatter({\n        state: this.state,\n        metadata: this.metadata\n      });\n      this.parser = new AsYouTypeParser({\n        defaultCountry: this.defaultCountry,\n        defaultCallingCode: this.defaultCallingCode,\n        metadata: this.metadata,\n        state: this.state,\n        onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {\n          _this.determineTheCountryIfNeeded();\n\n          _this.formatter.reset(_this.metadata.numberingPlan, _this.state);\n        }\n      });\n      this.state.reset(this.defaultCountry, this.defaultCallingCode);\n      this.formattedOutput = '';\n      return this;\n    }\n    /**\r\n     * Returns `true` if the phone number is being input in international format.\r\n     * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"isInternational\",\n    value: function isInternational() {\n      return this.state.international;\n    }\n    /**\r\n     * Returns the \"calling code\" part of the phone number when it's being input\r\n     * in an international format.\r\n     * If no valid calling code has been entered so far, returns `undefined`.\r\n     * @return {string} [callingCode]\r\n     */\n\n  }, {\n    key: \"getCallingCode\",\n    value: function getCallingCode() {\n      // If the number is being input in national format and some \"default calling code\"\n      // has been passed to `AsYouType` constructor, then `this.state.callingCode`\n      // is equal to that \"default calling code\".\n      //\n      // If the number is being input in national format and no \"default calling code\"\n      // has been passed to `AsYouType` constructor, then returns `undefined`,\n      // even if a \"default country\" has been passed to `AsYouType` constructor.\n      //\n      if (this.isInternational()) {\n        return this.state.callingCode;\n      }\n    } // A legacy alias.\n\n  }, {\n    key: \"getCountryCallingCode\",\n    value: function getCountryCallingCode() {\n      return this.getCallingCode();\n    }\n    /**\r\n     * Returns a two-letter country code of the phone number.\r\n     * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n     * Returns `undefined` if no phone number has been input yet.\r\n     * @return {string} [country]\r\n     */\n\n  }, {\n    key: \"getCountry\",\n    value: function getCountry() {\n      var digits = this.state.digits; // Return `undefined` if no digits have been input yet.\n\n      if (digits) {\n        return this._getCountry();\n      }\n    }\n    /**\r\n     * Returns a two-letter country code of the phone number.\r\n     * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n     * @return {string} [country]\r\n     */\n\n  }, {\n    key: \"_getCountry\",\n    value: function _getCountry() {\n      var country = this.state.country;\n      /* istanbul ignore if */\n\n      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n        // `AsYouType.getCountry()` returns `undefined`\n        // for \"non-geographic\" phone numbering plans.\n        if (country === '001') {\n          return;\n        }\n      }\n\n      return country;\n    }\n  }, {\n    key: \"determineTheCountryIfNeeded\",\n    value: function determineTheCountryIfNeeded() {\n      // Suppose a user enters a phone number in international format,\n      // and there're several countries corresponding to that country calling code,\n      // and a country has been derived from the number, and then\n      // a user enters one more digit and the number is no longer\n      // valid for the derived country, so the country should be re-derived\n      // on every new digit in those cases.\n      //\n      // If the phone number is being input in national format,\n      // then it could be a case when `defaultCountry` wasn't specified\n      // when creating `AsYouType` instance, and just `defaultCallingCode` was specified,\n      // and that \"calling code\" could correspond to a \"non-geographic entity\",\n      // or there could be several countries corresponding to that country calling code.\n      // In those cases, `this.country` is `undefined` and should be derived\n      // from the number. Again, if country calling code is ambiguous, then\n      // `this.country` should be re-derived with each new digit.\n      //\n      if (!this.state.country || this.isCountryCallingCodeAmbiguous()) {\n        this.determineTheCountry();\n      }\n    } // Prepends `+CountryCode ` in case of an international phone number\n\n  }, {\n    key: \"getFullNumber\",\n    value: function getFullNumber(formattedNationalNumber) {\n      var _this2 = this;\n\n      if (this.isInternational()) {\n        var prefix = function prefix(text) {\n          return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {\n            spacing: text ? true : false\n          }) + text;\n        };\n\n        var callingCode = this.state.callingCode;\n\n        if (!callingCode) {\n          return prefix(\"\".concat(this.state.getDigitsWithoutInternationalPrefix()));\n        }\n\n        if (!formattedNationalNumber) {\n          return prefix(callingCode);\n        }\n\n        return prefix(\"\".concat(callingCode, \" \").concat(formattedNationalNumber));\n      }\n\n      return formattedNationalNumber;\n    }\n  }, {\n    key: \"getNonFormattedNationalNumberWithPrefix\",\n    value: function getNonFormattedNationalNumberWithPrefix() {\n      var _this$state = this.state,\n          nationalSignificantNumber = _this$state.nationalSignificantNumber,\n          complexPrefixBeforeNationalSignificantNumber = _this$state.complexPrefixBeforeNationalSignificantNumber,\n          nationalPrefix = _this$state.nationalPrefix;\n      var number = nationalSignificantNumber;\n      var prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix;\n\n      if (prefix) {\n        number = prefix + number;\n      }\n\n      return number;\n    }\n  }, {\n    key: \"getNonFormattedNumber\",\n    value: function getNonFormattedNumber() {\n      var nationalSignificantNumberMatchesInput = this.state.nationalSignificantNumberMatchesInput;\n      return this.getFullNumber(nationalSignificantNumberMatchesInput ? this.getNonFormattedNationalNumberWithPrefix() : this.state.getNationalDigits());\n    }\n  }, {\n    key: \"getNonFormattedTemplate\",\n    value: function getNonFormattedTemplate() {\n      var number = this.getNonFormattedNumber();\n\n      if (number) {\n        return number.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER);\n      }\n    }\n  }, {\n    key: \"isCountryCallingCodeAmbiguous\",\n    value: function isCountryCallingCodeAmbiguous() {\n      var callingCode = this.state.callingCode;\n      var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);\n      return countryCodes && countryCodes.length > 1;\n    } // Determines the country of the phone number\n    // entered so far based on the country phone code\n    // and the national phone number.\n\n  }, {\n    key: \"determineTheCountry\",\n    value: function determineTheCountry() {\n      this.state.setCountry(getCountryByCallingCode(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, this.state.nationalSignificantNumber, this.metadata));\n    }\n    /**\r\n     * Returns a E.164 phone number value for the user's input.\r\n     *\r\n     * For example, for country `\"US\"` and input `\"(222) 333-4444\"`\r\n     * it will return `\"+12223334444\"`.\r\n     *\r\n     * For international phone number input, it will also auto-correct\r\n     * some minor errors such as using a national prefix when writing\r\n     * an international phone number. For example, if the user inputs\r\n     * `\"+44 0 7400 000000\"` then it will return an auto-corrected\r\n     * `\"+447400000000\"` phone number value.\r\n     *\r\n     * Will return `undefined` if no digits have been input,\r\n     * or when inputting a phone number in national format and no\r\n     * default country or default \"country calling code\" have been set.\r\n     *\r\n     * @return {string} [value]\r\n     */\n\n  }, {\n    key: \"getNumberValue\",\n    value: function getNumberValue() {\n      var _this$state2 = this.state,\n          digits = _this$state2.digits,\n          callingCode = _this$state2.callingCode,\n          country = _this$state2.country,\n          nationalSignificantNumber = _this$state2.nationalSignificantNumber; // Will return `undefined` if no digits have been input.\n\n      if (!digits) {\n        return;\n      }\n\n      if (this.isInternational()) {\n        if (callingCode) {\n          return '+' + callingCode + nationalSignificantNumber;\n        } else {\n          return '+' + digits;\n        }\n      } else {\n        if (country || callingCode) {\n          var callingCode_ = country ? this.metadata.countryCallingCode() : callingCode;\n          return '+' + callingCode_ + nationalSignificantNumber;\n        }\n      }\n    }\n    /**\r\n     * Returns an instance of `PhoneNumber` class.\r\n     * Will return `undefined` if no national (significant) number\r\n     * digits have been entered so far, or if no `defaultCountry` has been\r\n     * set and the user enters a phone number not in international format.\r\n     */\n\n  }, {\n    key: \"getNumber\",\n    value: function getNumber() {\n      var _this$state3 = this.state,\n          nationalSignificantNumber = _this$state3.nationalSignificantNumber,\n          carrierCode = _this$state3.carrierCode,\n          callingCode = _this$state3.callingCode; // `this._getCountry()` is basically same as `this.state.country`\n      // with the only change that it return `undefined` in case of a\n      // \"non-geographic\" numbering plan instead of `\"001\"` \"internal use\" value.\n\n      var country = this._getCountry();\n\n      if (!nationalSignificantNumber) {\n        return;\n      }\n\n      if (!country && !callingCode) {\n        return;\n      }\n\n      var phoneNumber = new PhoneNumber(country || callingCode, nationalSignificantNumber, this.metadata.metadata);\n\n      if (carrierCode) {\n        phoneNumber.carrierCode = carrierCode;\n      } // Phone number extensions are not supported by \"As You Type\" formatter.\n\n\n      return phoneNumber;\n    }\n    /**\r\n     * Returns `true` if the phone number is \"possible\".\r\n     * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"isPossible\",\n    value: function isPossible() {\n      var phoneNumber = this.getNumber();\n\n      if (!phoneNumber) {\n        return false;\n      }\n\n      return phoneNumber.isPossible();\n    }\n    /**\r\n     * Returns `true` if the phone number is \"valid\".\r\n     * Is just a shortcut for `PhoneNumber.isValid()`.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      var phoneNumber = this.getNumber();\n\n      if (!phoneNumber) {\n        return false;\n      }\n\n      return phoneNumber.isValid();\n    }\n    /**\r\n     * @deprecated\r\n     * This method is used in `react-phone-number-input/source/input-control.js`\r\n     * in versions before `3.0.16`.\r\n     */\n\n  }, {\n    key: \"getNationalNumber\",\n    value: function getNationalNumber() {\n      return this.state.nationalSignificantNumber;\n    }\n    /**\r\n     * Returns the phone number characters entered by the user.\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getChars\",\n    value: function getChars() {\n      return (this.state.international ? '+' : '') + this.state.digits;\n    }\n    /**\r\n     * Returns the template for the formatted phone number.\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate() {\n      return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || '';\n    }\n  }]);\n\n  return AsYouType;\n}();\n\nexport { AsYouType as default };\n//# sourceMappingURL=AsYouType.js.map","// Importing from a \".js\" file is a workaround for Node.js \"ES Modules\"\r\n// importing system which is even uncapable of importing \"*.json\" files.\r\nimport metadata from '../../metadata.min.json.js'\r\n\r\nimport { AsYouType as _AsYouType } from '../../core/index.js'\r\n\r\nexport function AsYouType(country) {\r\n\treturn _AsYouType.call(this, country, metadata)\r\n}\r\n\r\nAsYouType.prototype = Object.create(_AsYouType.prototype, {})\r\nAsYouType.prototype.constructor = AsYouType"],"sourceRoot":""}